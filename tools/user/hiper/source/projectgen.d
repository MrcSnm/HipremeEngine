module projectgen;
import std.path:buildNormalizedPath;
import std.file;
import std.format:format;
import std.process;
import std.array:join,split,array;

string getHipremeEnginePathFromEnv()
{
	string hipEnginePath = environment["HIPREME_ENGINE"].escapeWindowsPathSep;
	if(hipEnginePath.length)
	{
		if(hipEnginePath[0] == '"') hipEnginePath = hipEnginePath[1..$];
		if(hipEnginePath[$-1] == '"') hipEnginePath = hipEnginePath[0..$-1];
	}
	return hipEnginePath;
}

struct TemplateInfo
{
	string initMethod=q{
		setFont(HipDefaultAssets.getDefaultFontWithSize(62));
	},
	update="",
	render=q{
		drawText("You can start using the D Scripting API Here!", 400, 300, HipColor.white, 
			HipTextAlign.CENTER,  HipTextAlign.CENTER
		);
	},
	dispose="";
}

struct DubProjectInfo
{
	string author = "HipremeEngine";
	string projectName = "Hipreme Engine Test";
	string desc = "Hipreme Engine test scene";
}

string generateCodeTemplate(TemplateInfo info = TemplateInfo())
{
	return format!q{
module gamescript.entry;
import hip.api;

/**
*	Call `dub` to generate the DLL, after that, just execute `dub -c run` for starting your project
*/
class MainScene : AScene, IHipPreloadable
{
	mixin Preload;
	
	/** Constructor */
	override void initialize()
	{
		%s
	}
	/** Called every frame */
	override void update(float dt)
	{
		%s
	}
	/** Renderer only, may not be called every frame */
	override void render()
	{
		%s
	}
	/** Pre destroy */
	override void dispose()
	{
		%s
	}
	void onResize(uint width, uint height){}
}

mixin HipEngineMain!MainScene;
	}(info.initMethod, info.update, info.render, info.dispose);
}


string escapeWindowsPathSep(string input)
{
	string output = "";
	foreach(ch; input)
		if(ch == '\\')
			output~="\\\\";
		else
			output~= ch;
	return output;
}

string generateDubProject(DubProjectInfo info, string projectPath)
{
	import std.conv;
	import std.uni:toLower;
	import std.algorithm:map;
	dstring outputName = info.projectName.split(" ").join("_").array;
	dstring name = outputName.map!(character => character.toLower).array;

	string hipEnginePath = getHipremeEnginePathFromEnv();
	projectPath = projectPath.escapeWindowsPathSep;


	return format!`{
	"authors": ["%s"],
	"description" : "%s",
	"license": "proprietary",
	"targetName" : "%s",
	"name" : "%s",
	"sourcePaths"  : ["source"],
	"dependencies": 
	{
		"hipengine_api": {"path": "%s/api"},
		"util": {"path": "%s/modules/util"},
		"timer": {"path": "%s/modules/timer"},
		"tween": {"path": "%s/modules/tween"},
		"math": {"path": "%s/modules/math"}
	},
	"stringImportPaths": [
		"."
	],
	"preBuildCommands": [
		"rdmd $HIPREME_ENGINE/tools/build/getmodules.d source/ scriptmodules.txt"
	],
	"dflags-linux-ldc": [
		"-link-defaultlib-shared=false"
	],
	"lflags-windows-ldc": [
		"/WHOLEARCHIVE:hipengine_api",
		"/WHOLEARCHIVE:util",
		"/WHOLEARCHIVE:timer",
		"/WHOLEARCHIVE:tween",
		"/WHOLEARCHIVE:math"
	],
	"configurations": 
	[
		{
			"name" : "script",
			"targetType": "dynamicLibrary",
			"lflags-windows": [
				"/WX"
			]
		},
		{
			"name": "run",
			"targetType": "dynamicLibrary",
			"lflags-windows": [
				"/WX"
			],
			"postGenerateCommands-windows": ["cd /d %s && dub -c script -- %s"],
			"postGenerateCommands-linux": ["cd %s && dub -c script -- %s"]
		}
	],
	"versions" : [
		"HipMathAPI",
		"HipremeAudio"
	]
}
`(info.author, info.desc, outputName, name, 
	//Modules Here
	hipEnginePath, hipEnginePath, hipEnginePath, hipEnginePath, hipEnginePath, 
	//Post Build Commands
	hipEnginePath, projectPath,
	hipEnginePath, projectPath);
}

string generateVSCodeDebuggerLaunch()
{
	import std.system;
	string hipEnginePath = getHipremeEnginePathFromEnv();
	string hipEngineExecutable = (buildNormalizedPath(hipEnginePath, "bin", "desktop", "hipreme_engine") ~ ((os == OS.linux) ? "" : ".exe")).escapeWindowsPathSep;
	return format!q{
{
    // Use IntelliSense to learn about possible attributes.
    // Hover to view descriptions of existing attributes.
    // For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387
	// Auto Generated by HipremeEngine Hiper project generator.
	// Automatically handle SIGUSR1 and SIGUSR2 as they are currently used in semaphore.wait
    "version": "0.2.0",
    "configurations": [
        {
            "name": "Debug",
            "type": "gdb",
            "request": "launch",
            "target": "%s",
            "cwd": "${workspaceRoot}",
            "arguments": "${workspaceRoot}",
            "debugger_args": [
                "-ex", "handle SIGUSR1 noprint",
                "-ex", "handle SIGUSR2 noprint"
            ]
        }
    ]
}
}(hipEngineExecutable);
}

void generateProject(string projectPath,
DubProjectInfo dubInfo, TemplateInfo templateInfo)
{
	string dubProj = generateDubProject(dubInfo, projectPath);
	string codeTemplate = generateCodeTemplate(templateInfo);
	string debugLauncher = generateVSCodeDebuggerLaunch();
	import std.stdio;
	try
	{
	    //Project folder
		writeln("Creating project folder");
		mkdirRecurse(projectPath);
		//Source Folder
		writeln("Creating scripts folder");
		mkdirRecurse(buildNormalizedPath(projectPath, "source", "gamescript"));
		//Assets Folder
		writeln("Creating assets folder");
		mkdirRecurse(buildNormalizedPath(projectPath, "assets"));
		//VSCode Folder
		writeln("Creating vscode folder");
		mkdirRecurse(buildNormalizedPath(projectPath, ".vscode"));

		writeln("Writing code template for gamescript/entry.d");
		std.file.write(buildNormalizedPath(projectPath, "source", "gamescript", "entry.d"), codeTemplate);
		writeln("Writing dub.json");
		std.file.write(buildNormalizedPath(projectPath, "dub.json"), dubProj);
		writeln("Writing README.md");
		std.file.write(buildNormalizedPath(projectPath, "README.md"), dubInfo.projectName~" made using Hipreme Engine");
		writeln("Writing VSCode debug launcher");
		std.file.write(buildNormalizedPath(projectPath, ".vscode", "launch.json"), debugLauncher);

		writeln("Writing .gitignore");
		std.file.write(buildNormalizedPath(projectPath, ".gitignore"),  q{
.dub
.history
.vs
bin
*.exe
*.dll
*.dll_hiptempdll
*.so
*.lib
*.a
*.pdb
});
	}
	catch(Exception e)
	{
		import std.stdio;
		writeln(e.toString);
	}
}