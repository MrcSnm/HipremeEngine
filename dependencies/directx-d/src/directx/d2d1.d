module directx.d2d1;
//---------------------------------------------------------------------------
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
// This file is automatically generated.  Please do not edit it directly.
//
// File name: D2D1.h
//---------------------------------------------------------------------------

version(Windows):

public import directx.dcommon;
public import directx.d2derr;
public import directx.d2dbasetypes;
public import directx.dxgi;

import directx.d3dcommon;
import directx.dwrite;
import directx.wincodec;

static if ( __traits(compiles, UINT32.sizeof) )
{
}
else
{
	alias UINT32 = uint;
}

alias UINT64 = ulong; // for D2D1_TAG
enum ULONGLONG_MAX = ulong.max;
enum D2D1_INVALID_TAG = ULONGLONG_MAX;
enum D2D1_DEFAULT_FLATTENING_TOLERANCE = 0.25f;


//+-----------------------------------------------------------------------------
//
//  Enum:
//      D2D1_INTERPOLATION_MODE_DEFINITION
//
//  Synopsis:
//      This defines the superset of interpolation mode supported by D2D APIs
//      and built-in effects
//
//------------------------------------------------------------------------------
enum 
{
    D2D1_INTERPOLATION_MODE_DEFINITION_NEAREST_NEIGHBOR = 0,
    D2D1_INTERPOLATION_MODE_DEFINITION_LINEAR = 1,
    D2D1_INTERPOLATION_MODE_DEFINITION_CUBIC = 2,
    D2D1_INTERPOLATION_MODE_DEFINITION_MULTI_SAMPLE_LINEAR = 3,
    D2D1_INTERPOLATION_MODE_DEFINITION_ANISOTROPIC = 4,
    D2D1_INTERPOLATION_MODE_DEFINITION_HIGH_QUALITY_CUBIC = 5,
    D2D1_INTERPOLATION_MODE_DEFINITION_FANT = 6,
    D2D1_INTERPOLATION_MODE_DEFINITION_MIPMAP_LINEAR = 7

}


//+-----------------------------------------------------------------------------
//
//  Enum:
//      D2D1_GAMMA
//
//  Synopsis:
//      This determines what gamma is used for interpolation/blending.
//
//------------------------------------------------------------------------------
alias D2D1_GAMMA = int;
enum : D2D1_GAMMA
{
        
        //
        // Colors are manipulated in 2.2 gamma color space.
        //
        D2D1_GAMMA_2_2 = 0,
        
        //
        // Colors are manipulated in 1.0 gamma color space.
        //
        D2D1_GAMMA_1_0 = 1,
        D2D1_GAMMA_FORCE_DWORD = 0xffffffff

}


//+-----------------------------------------------------------------------------
//
//  Enum:
//      D2D1_OPACITY_MASK_CONTENT
//
//  Synopsis:
//      Specifies what the contents are of an opacity mask.
//
//------------------------------------------------------------------------------
alias D2D1_OPACITY_MASK_CONTENT = int;
enum : D2D1_OPACITY_MASK_CONTENT
{
        
        //
        // The mask contains geometries or bitmaps.
        //
        D2D1_OPACITY_MASK_CONTENT_GRAPHICS = 0,
        
        //
        // The mask contains text rendered using one of the natural text modes.
        //
        D2D1_OPACITY_MASK_CONTENT_TEXT_NATURAL = 1,
        
        //
        // The mask contains text rendered using one of the GDI compatible text modes.
        //
        D2D1_OPACITY_MASK_CONTENT_TEXT_GDI_COMPATIBLE = 2,
        D2D1_OPACITY_MASK_CONTENT_FORCE_DWORD = 0xffffffff

}


//+-----------------------------------------------------------------------------
//
//  Enum:
//      D2D1_EXTEND_MODE
//
//  Synopsis:
//      Enum which describes how to sample from a source outside its base tile.
//
//------------------------------------------------------------------------------
alias D2D1_EXTEND_MODE = int;
enum : D2D1_EXTEND_MODE
{
        
        //
        // Extend the edges of the source out by clamping sample points outside the source
        // to the edges.
        //
        D2D1_EXTEND_MODE_CLAMP = 0,
        
        //
        // The base tile is drawn untransformed and the remainder are filled by repeating
        // the base tile.
        //
        D2D1_EXTEND_MODE_WRAP = 1,
        
        //
        // The same as wrap, but alternate tiles are flipped  The base tile is drawn
        // untransformed.
        //
        D2D1_EXTEND_MODE_MIRROR = 2,
        D2D1_EXTEND_MODE_FORCE_DWORD = 0xffffffff

}


//+-----------------------------------------------------------------------------
//
//  Enum:
//      D2D1_ANTIALIAS_MODE
//
//  Synopsis:
//      Enum which describes the manner in which we render edges of non-text primitives.
//
//------------------------------------------------------------------------------
alias D2D1_ANTIALIAS_MODE = int;
enum : D2D1_ANTIALIAS_MODE
{
        
        //
        // The edges of each primitive are antialiased sequentially.
        //
        D2D1_ANTIALIAS_MODE_PER_PRIMITIVE = 0,
        
        //
        // Each pixel is rendered if its pixel center is contained by the geometry.
        //
        D2D1_ANTIALIAS_MODE_ALIASED = 1,
        D2D1_ANTIALIAS_MODE_FORCE_DWORD = 0xffffffff

}


//+-----------------------------------------------------------------------------
//
//  Enum:
//      D2D1_TEXT_ANTIALIAS_MODE
//
//------------------------------------------------------------------------------
alias D2D1_TEXT_ANTIALIAS_MODE = int;
enum : D2D1_TEXT_ANTIALIAS_MODE
{
        
        //
        // Render text using the current system setting.
        //
        D2D1_TEXT_ANTIALIAS_MODE_DEFAULT = 0,
        
        //
        // Render text using ClearType.
        //
        D2D1_TEXT_ANTIALIAS_MODE_CLEARTYPE = 1,
        
        //
        // Render text using gray-scale.
        //
        D2D1_TEXT_ANTIALIAS_MODE_GRAYSCALE = 2,
        
        //
        // Render text aliased.
        //
        D2D1_TEXT_ANTIALIAS_MODE_ALIASED = 3,
        D2D1_TEXT_ANTIALIAS_MODE_FORCE_DWORD = 0xffffffff

}


//+-----------------------------------------------------------------------------
//
//  Enum:
//      D2D1_BITMAP_INTERPOLATION_MODE
//
//------------------------------------------------------------------------------
alias D2D1_BITMAP_INTERPOLATION_MODE = int;
enum : D2D1_BITMAP_INTERPOLATION_MODE
{
        
        //
        // Nearest Neighbor filtering. Also known as nearest pixel or nearest point
        // sampling.
        //
        D2D1_BITMAP_INTERPOLATION_MODE_NEAREST_NEIGHBOR = D2D1_INTERPOLATION_MODE_DEFINITION_NEAREST_NEIGHBOR,
        
        //
        // Linear filtering.
        //
        D2D1_BITMAP_INTERPOLATION_MODE_LINEAR = D2D1_INTERPOLATION_MODE_DEFINITION_LINEAR,
        D2D1_BITMAP_INTERPOLATION_MODE_FORCE_DWORD = 0xffffffff

}


//+-----------------------------------------------------------------------------
//
//  Flag:
//      D2D1_DRAW_TEXT_OPTIONS
//
//  Synopsis:
//      Modifications made to the draw text call that influence how the text is
//      rendered.
//
//------------------------------------------------------------------------------
alias D2D1_DRAW_TEXT_OPTIONS = int;
enum : D2D1_DRAW_TEXT_OPTIONS
{
        
        //
        // Do not snap the baseline of the text vertically.
        //
        D2D1_DRAW_TEXT_OPTIONS_NO_SNAP = 0x00000001,
        
        //
        // Clip the text to the content bounds.
        //
        D2D1_DRAW_TEXT_OPTIONS_CLIP = 0x00000002,
        
        //
        // Render color versions of glyphs if defined by the font.
        //
        D2D1_DRAW_TEXT_OPTIONS_ENABLE_COLOR_FONT = 0x00000004,
        D2D1_DRAW_TEXT_OPTIONS_NONE = 0x00000000,
        D2D1_DRAW_TEXT_OPTIONS_FORCE_DWORD = 0xffffffff

}

// TODO: translate this
//DEFINE_ENUM_FLAG_OPERATORS(D2D1_DRAW_TEXT_OPTIONS);

alias D2D1_POINT_2U = D2D_POINT_2U;
alias D2D1_POINT_2F = D2D_POINT_2F;
alias D2D1_RECT_F = D2D_RECT_F;
alias D2D1_RECT_U = D2D_RECT_U;
alias D2D1_SIZE_F = D2D_SIZE_F;
alias D2D1_SIZE_U = D2D_SIZE_U;
alias D2D1_COLOR_F = D2D_COLOR_F;
alias D2D1_MATRIX_3X2_F = D2D_MATRIX_3X2_F;
alias D2D1_TAG = UINT64;

//+-----------------------------------------------------------------------------
//
//  Struct:
//      D2D1_BITMAP_PROPERTIES
//
//------------------------------------------------------------------------------
struct D2D1_BITMAP_PROPERTIES
{
    D2D1_PIXEL_FORMAT pixelFormat;
    FLOAT dpiX;
    FLOAT dpiY;
}


//+-----------------------------------------------------------------------------
//
//  Struct:
//      D2D1_GRADIENT_STOP
//
//------------------------------------------------------------------------------
struct D2D1_GRADIENT_STOP
{
    FLOAT position;
    D2D1_COLOR_F color;

}


//+-----------------------------------------------------------------------------
//
//  Struct:
//      D2D1_BRUSH_PROPERTIES
//
//------------------------------------------------------------------------------
struct D2D1_BRUSH_PROPERTIES
{
    FLOAT opacity;
    D2D1_MATRIX_3X2_F transform;

}


//+-----------------------------------------------------------------------------
//
//  Struct:
//      D2D1_BITMAP_BRUSH_PROPERTIES
//
//------------------------------------------------------------------------------
struct D2D1_BITMAP_BRUSH_PROPERTIES
{
    D2D1_EXTEND_MODE extendModeX;
    D2D1_EXTEND_MODE extendModeY;
    D2D1_BITMAP_INTERPOLATION_MODE interpolationMode;

}


//+-----------------------------------------------------------------------------
//
//  Struct:
//      D2D1_LINEAR_GRADIENT_BRUSH_PROPERTIES
//
//------------------------------------------------------------------------------
struct D2D1_LINEAR_GRADIENT_BRUSH_PROPERTIES
{
    D2D1_POINT_2F startPoint;
    D2D1_POINT_2F endPoint;

}


//+-----------------------------------------------------------------------------
//
//  Struct:
//      D2D1_RADIAL_GRADIENT_BRUSH_PROPERTIES
//
//------------------------------------------------------------------------------
struct D2D1_RADIAL_GRADIENT_BRUSH_PROPERTIES
{
    D2D1_POINT_2F center;
    D2D1_POINT_2F gradientOriginOffset;
    FLOAT radiusX;
    FLOAT radiusY;

}


//+-----------------------------------------------------------------------------
//
//  Enum:
//      D2D1_ARC_SIZE
//
//  Synopsis:
//      Differentiates which of the two possible arcs could match the given arc
//      parameters.
//
//------------------------------------------------------------------------------
alias D2D1_ARC_SIZE = int;
enum : D2D1_ARC_SIZE
{
        D2D1_ARC_SIZE_SMALL = 0,
        D2D1_ARC_SIZE_LARGE = 1,
        D2D1_ARC_SIZE_FORCE_DWORD = 0xffffffff

}


//+-----------------------------------------------------------------------------
//
//  Enum:
//      D2D1_CAP_STYLE
//
//  Synopsis:
//      Enum which describes the drawing of the ends of a line.
//
//------------------------------------------------------------------------------
alias D2D1_CAP_STYLE = int;
enum : D2D1_CAP_STYLE
{
        
        //
        // Flat line cap.
        //
        D2D1_CAP_STYLE_FLAT = 0,
        
        //
        // Square line cap.
        //
        D2D1_CAP_STYLE_SQUARE = 1,
        
        //
        // Round line cap.
        //
        D2D1_CAP_STYLE_ROUND = 2,
        
        //
        // Triangle line cap.
        //
        D2D1_CAP_STYLE_TRIANGLE = 3,
        D2D1_CAP_STYLE_FORCE_DWORD = 0xffffffff

}


//+-----------------------------------------------------------------------------
//
//  Enum:
//      D2D1_DASH_STYLE
//
//------------------------------------------------------------------------------
alias D2D1_DASH_STYLE = int;
enum : D2D1_DASH_STYLE
{
        D2D1_DASH_STYLE_SOLID = 0,
        D2D1_DASH_STYLE_DASH = 1,
        D2D1_DASH_STYLE_DOT = 2,
        D2D1_DASH_STYLE_DASH_DOT = 3,
        D2D1_DASH_STYLE_DASH_DOT_DOT = 4,
        D2D1_DASH_STYLE_CUSTOM = 5,
        D2D1_DASH_STYLE_FORCE_DWORD = 0xffffffff

}


//+-----------------------------------------------------------------------------
//
//  Enum:
//      D2D1_LINE_JOIN
//
//  Synopsis:
//      Enum which describes the drawing of the corners on the line.
//
//------------------------------------------------------------------------------
alias D2D1_LINE_JOIN = int;
enum : D2D1_LINE_JOIN
{
        
        //
        // Miter join.
        //
        D2D1_LINE_JOIN_MITER = 0,
        
        //
        // Bevel join.
        //
        D2D1_LINE_JOIN_BEVEL = 1,
        
        //
        // Round join.
        //
        D2D1_LINE_JOIN_ROUND = 2,
        
        //
        // Miter/Bevel join.
        //
        D2D1_LINE_JOIN_MITER_OR_BEVEL = 3,
        D2D1_LINE_JOIN_FORCE_DWORD = 0xffffffff

}


//+-----------------------------------------------------------------------------
//
//  Enum:
//      D2D1_COMBINE_MODE
//
//  Synopsis:
//      This enumeration describes the type of combine operation to be performed.
//
//------------------------------------------------------------------------------
alias D2D1_COMBINE_MODE = int;
enum : D2D1_COMBINE_MODE
{
        
        //
        // Produce a geometry representing the set of points contained in either
        // the first or the second geometry.
        //
        D2D1_COMBINE_MODE_UNION = 0,
        
        //
        // Produce a geometry representing the set of points common to the first
        // and the second geometries.
        //
        D2D1_COMBINE_MODE_INTERSECT = 1,
        
        //
        // Produce a geometry representing the set of points contained in the
        // first geometry or the second geometry, but not both.
        //
        D2D1_COMBINE_MODE_XOR = 2,
        
        //
        // Produce a geometry representing the set of points contained in the
        // first geometry but not the second geometry.
        //
        D2D1_COMBINE_MODE_EXCLUDE = 3,
        D2D1_COMBINE_MODE_FORCE_DWORD = 0xffffffff

}


//+-----------------------------------------------------------------------------
//
//  Enum:
//      D2D1_GEOMETRY_RELATION
//
//------------------------------------------------------------------------------
alias D2D1_GEOMETRY_RELATION = int;
enum : D2D1_GEOMETRY_RELATION
{
        
        //
        // The relation between the geometries couldn't be determined. This value is never
        // returned by any D2D method.
        //
        D2D1_GEOMETRY_RELATION_UNKNOWN = 0,
        
        //
        // The two geometries do not intersect at all.
        //
        D2D1_GEOMETRY_RELATION_DISJOINT = 1,
        
        //
        // The passed in geometry is entirely contained by the object.
        //
        D2D1_GEOMETRY_RELATION_IS_CONTAINED = 2,
        
        //
        // The object entirely contains the passed in geometry.
        //
        D2D1_GEOMETRY_RELATION_CONTAINS = 3,
        
        //
        // The two geometries overlap but neither completely contains the other.
        //
        D2D1_GEOMETRY_RELATION_OVERLAP = 4,
        D2D1_GEOMETRY_RELATION_FORCE_DWORD = 0xffffffff

}


//+-----------------------------------------------------------------------------
//
//  Enum:
//      D2D1_GEOMETRY_SIMPLIFICATION_OPTION
//
//  Synopsis:
//      Specifies how simple the output of a simplified geometry sink should be.
//
//------------------------------------------------------------------------------
alias D2D1_GEOMETRY_SIMPLIFICATION_OPTION = int;
enum : D2D1_GEOMETRY_SIMPLIFICATION_OPTION
{
        D2D1_GEOMETRY_SIMPLIFICATION_OPTION_CUBICS_AND_LINES = 0,
        D2D1_GEOMETRY_SIMPLIFICATION_OPTION_LINES = 1,
        D2D1_GEOMETRY_SIMPLIFICATION_OPTION_FORCE_DWORD = 0xffffffff

}


//+-----------------------------------------------------------------------------
//
//  Enum:
//      D2D1_FIGURE_BEGIN
//
//  Synopsis:
//      Indicates whether the given figure is filled or hollow.
//
//------------------------------------------------------------------------------
alias D2D1_FIGURE_BEGIN = int;
enum : D2D1_FIGURE_BEGIN
{
        D2D1_FIGURE_BEGIN_FILLED = 0,
        D2D1_FIGURE_BEGIN_HOLLOW = 1,
        D2D1_FIGURE_BEGIN_FORCE_DWORD = 0xffffffff

}


//+-----------------------------------------------------------------------------
//
//  Enum:
//      D2D1_FIGURE_END
//
//  Synopsis:
//      Indicates whether the figure is open or closed on its end point.
//
//------------------------------------------------------------------------------
alias D2D1_FIGURE_END = int;
enum : D2D1_FIGURE_END
{
        D2D1_FIGURE_END_OPEN = 0,
        D2D1_FIGURE_END_CLOSED = 1,
        D2D1_FIGURE_END_FORCE_DWORD = 0xffffffff

}


//+-----------------------------------------------------------------------------
//
//  Struct:
//      D2D1_BEZIER_SEGMENT
//
//  Synopsis:
//      Describes a cubic bezier in a path.
//
//------------------------------------------------------------------------------
struct D2D1_BEZIER_SEGMENT
{
    D2D1_POINT_2F point1;
    D2D1_POINT_2F point2;
    D2D1_POINT_2F point3;

}


//+-----------------------------------------------------------------------------
//
//  Struct:
//      D2D1_TRIANGLE
//
//  Synopsis:
//      Describes a triangle.
//
//------------------------------------------------------------------------------
struct D2D1_TRIANGLE
{
    D2D1_POINT_2F point1;
    D2D1_POINT_2F point2;
    D2D1_POINT_2F point3;

}


//+-----------------------------------------------------------------------------
//
//  Flag:
//      D2D1_PATH_SEGMENT
//
//  Synopsis:
//      Indicates whether the given segment should be stroked, or, if the join between
//      this segment and the previous one should be smooth.
//
//------------------------------------------------------------------------------
alias D2D1_PATH_SEGMENT = int;
enum : D2D1_PATH_SEGMENT
{
        D2D1_PATH_SEGMENT_NONE = 0x00000000,
        D2D1_PATH_SEGMENT_FORCE_UNSTROKED = 0x00000001,
        D2D1_PATH_SEGMENT_FORCE_ROUND_LINE_JOIN = 0x00000002,
        D2D1_PATH_SEGMENT_FORCE_DWORD = 0xffffffff

}

// TODO: translate this
//DEFINE_ENUM_FLAG_OPERATORS(D2D1_PATH_SEGMENT);


//+-----------------------------------------------------------------------------
//
//  Enum:
//      D2D1_SWEEP_DIRECTION
//
//------------------------------------------------------------------------------
alias D2D1_SWEEP_DIRECTION = int;
enum : D2D1_SWEEP_DIRECTION
{
        D2D1_SWEEP_DIRECTION_COUNTER_CLOCKWISE = 0,
        D2D1_SWEEP_DIRECTION_CLOCKWISE = 1,
        D2D1_SWEEP_DIRECTION_FORCE_DWORD = 0xffffffff

}


//+-----------------------------------------------------------------------------
//
//  Enum:
//      D2D1_FILL_MODE
//
//------------------------------------------------------------------------------
alias D2D1_FILL_MODE = int;
enum : D2D1_FILL_MODE
{
        D2D1_FILL_MODE_ALTERNATE = 0,
        D2D1_FILL_MODE_WINDING = 1,
        D2D1_FILL_MODE_FORCE_DWORD = 0xffffffff

}


//+-----------------------------------------------------------------------------
//
//  Struct:
//      D2D1_ARC_SEGMENT
//
//  Synopsis:
//      Describes an arc that is defined as part of a path.
//
//------------------------------------------------------------------------------
struct D2D1_ARC_SEGMENT
{
    D2D1_POINT_2F point;
    D2D1_SIZE_F size;
    FLOAT rotationAngle;
    D2D1_SWEEP_DIRECTION sweepDirection;
    D2D1_ARC_SIZE arcSize;

}


//+-----------------------------------------------------------------------------
//
//  Struct:
//      D2D1_QUADRATIC_BEZIER_SEGMENT
//
//------------------------------------------------------------------------------
struct D2D1_QUADRATIC_BEZIER_SEGMENT
{
    D2D1_POINT_2F point1;
    D2D1_POINT_2F point2;

}


//+-----------------------------------------------------------------------------
//
//  Struct:
//      D2D1_ELLIPSE
//
//------------------------------------------------------------------------------
struct D2D1_ELLIPSE
{
    D2D1_POINT_2F point;
    FLOAT radiusX;
    FLOAT radiusY;

}


//+-----------------------------------------------------------------------------
//
//  Struct:
//      D2D1_ROUNDED_RECT
//
//------------------------------------------------------------------------------
struct D2D1_ROUNDED_RECT
{
    D2D1_RECT_F rect;
    FLOAT radiusX;
    FLOAT radiusY;

}


//+-----------------------------------------------------------------------------
//
//  Struct:
//      D2D1_STROKE_STYLE_PROPERTIES
//
//  Synopsis:
//      Properties, aside from the width, that allow geometric penning to be specified.
//
//------------------------------------------------------------------------------
struct D2D1_STROKE_STYLE_PROPERTIES
{
    D2D1_CAP_STYLE startCap;
    D2D1_CAP_STYLE endCap;
    D2D1_CAP_STYLE dashCap;
    D2D1_LINE_JOIN lineJoin;
    FLOAT miterLimit;
    D2D1_DASH_STYLE dashStyle;
    FLOAT dashOffset;

}


//+-----------------------------------------------------------------------------
//
//  Flag:
//      D2D1_LAYER_OPTIONS
//
//  Synopsis:
//      Specified options that can be applied when a layer resource is applied to create
//      a layer.
//
//------------------------------------------------------------------------------
alias D2D1_LAYER_OPTIONS = int;
enum : D2D1_LAYER_OPTIONS
{
        D2D1_LAYER_OPTIONS_NONE = 0x00000000,
        
        //
        // The layer will render correctly for ClearType text. If the render target was set
        // to ClearType previously, the layer will continue to render ClearType. If the
        // render target was set to ClearType and this option is not specified, the render
        // target will be set to render gray-scale until the layer is popped. The caller
        // can override this default by calling SetTextAntialiasMode while within the
        // layer. This flag is slightly slower than the default.
        //
        D2D1_LAYER_OPTIONS_INITIALIZE_FOR_CLEARTYPE = 0x00000001,
        D2D1_LAYER_OPTIONS_FORCE_DWORD = 0xffffffff

}

// TODO: translate this
//DEFINE_ENUM_FLAG_OPERATORS(D2D1_LAYER_OPTIONS);


//+-----------------------------------------------------------------------------
//
//  Struct:
//      D2D1_LAYER_PARAMETERS
//
//------------------------------------------------------------------------------
struct D2D1_LAYER_PARAMETERS
{
    
    //
    // The rectangular clip that will be applied to the layer. The clip is affected by
    // the world transform. Content outside of the content bounds will not render.
    //
    D2D1_RECT_F contentBounds;
    
    //
    // A general mask that can be optionally applied to the content. Content not inside
    // the fill of the mask will not be rendered.
    //
    ID2D1Geometry geometricMask; // 1-byte aligned?
    
    //
    // Specifies whether the mask should be aliased or antialiased.
    //
    D2D1_ANTIALIAS_MODE maskAntialiasMode;
    
    //
    // An additional transform that may be applied to the mask in addition to the
    // current world transform.
    //
    D2D1_MATRIX_3X2_F maskTransform;
    
    //
    // The opacity with which all of the content in the layer will be blended back to
    // the target when the layer is popped.
    //
    FLOAT opacity;
    
    //
    // An additional brush that can be applied to the layer. Only the opacity channel
    // is sampled from this brush and multiplied both with the layer content and the
    // over-all layer opacity.
    //
    ID2D1Brush opacityBrush; // 1-byte aligned?
    
    //
    // Specifies if ClearType will be rendered into the layer.
    //
    D2D1_LAYER_OPTIONS layerOptions;

}


//+-----------------------------------------------------------------------------
//
//  Flag:
//      D2D1_WINDOW_STATE
//
//------------------------------------------------------------------------------
alias D2D1_WINDOW_STATE = int;
enum : D2D1_WINDOW_STATE
{
        D2D1_WINDOW_STATE_NONE = 0x0000000,
        D2D1_WINDOW_STATE_OCCLUDED = 0x0000001,
        D2D1_WINDOW_STATE_FORCE_DWORD = 0xffffffff

}

// TODO: translate this
//DEFINE_ENUM_FLAG_OPERATORS(D2D1_WINDOW_STATE);


//+-----------------------------------------------------------------------------
//
//  Enum:
//      D2D1_RENDER_TARGET_TYPE
//
//------------------------------------------------------------------------------
alias D2D1_RENDER_TARGET_TYPE = int;
enum : D2D1_RENDER_TARGET_TYPE
{
        
        //
        // D2D is free to choose the render target type for the caller.
        //
        D2D1_RENDER_TARGET_TYPE_DEFAULT = 0,
        
        //
        // The render target will render using the CPU.
        //
        D2D1_RENDER_TARGET_TYPE_SOFTWARE = 1,
        
        //
        // The render target will render using the GPU.
        //
        D2D1_RENDER_TARGET_TYPE_HARDWARE = 2,
        D2D1_RENDER_TARGET_TYPE_FORCE_DWORD = 0xffffffff

}


//+-----------------------------------------------------------------------------
//
//  Enum:
//      D2D1_FEATURE_LEVEL
//
//------------------------------------------------------------------------------
alias D2D1_FEATURE_LEVEL = int;
enum : D2D1_FEATURE_LEVEL
{
        
        //
        // The caller does not require a particular underlying D3D device level.
        //
        D2D1_FEATURE_LEVEL_DEFAULT = 0,
        
        //
        // The D3D device level is DX9 compatible.
        //
        D2D1_FEATURE_LEVEL_9 = D3D_FEATURE_LEVEL_9_1,
        
        //
        // The D3D device level is DX10 compatible.
        //
        D2D1_FEATURE_LEVEL_10 = D3D_FEATURE_LEVEL_10_0,
        D2D1_FEATURE_LEVEL_FORCE_DWORD = 0xffffffff

}


//+-----------------------------------------------------------------------------
//
//  Flag:
//      D2D1_RENDER_TARGET_USAGE
//
//------------------------------------------------------------------------------
alias D2D1_RENDER_TARGET_USAGE = int;
enum : D2D1_RENDER_TARGET_USAGE
{
        D2D1_RENDER_TARGET_USAGE_NONE = 0x00000000,
        
        //
        // Rendering will occur locally, if a terminal-services session is established, the
        // bitmap updates will be sent to the terminal services client.
        //
        D2D1_RENDER_TARGET_USAGE_FORCE_BITMAP_REMOTING = 0x00000001,
        
        //
        // The render target will allow a call to GetDC on the ID2D1GdiInteropRenderTarget
        // interface. Rendering will also occur locally.
        //
        D2D1_RENDER_TARGET_USAGE_GDI_COMPATIBLE = 0x00000002,
        D2D1_RENDER_TARGET_USAGE_FORCE_DWORD = 0xffffffff

}

// TODO: translate this
//DEFINE_ENUM_FLAG_OPERATORS(D2D1_RENDER_TARGET_USAGE);


//+-----------------------------------------------------------------------------
//
//  Flag:
//      D2D1_PRESENT_OPTIONS
//
//  Synopsis:
//      Describes how present should behave.
//
//------------------------------------------------------------------------------
alias D2D1_PRESENT_OPTIONS = int;
enum : D2D1_PRESENT_OPTIONS
{
        D2D1_PRESENT_OPTIONS_NONE = 0x00000000,
        
        //
        // Keep the target contents intact through present.
        //
        D2D1_PRESENT_OPTIONS_RETAIN_CONTENTS = 0x00000001,
        
        //
        // Do not wait for display refresh to commit changes to display.
        //
        D2D1_PRESENT_OPTIONS_IMMEDIATELY = 0x00000002,
        D2D1_PRESENT_OPTIONS_FORCE_DWORD = 0xffffffff

}

// TODO: translate this
//DEFINE_ENUM_FLAG_OPERATORS(D2D1_PRESENT_OPTIONS);


//+-----------------------------------------------------------------------------
//
//  Struct:
//      D2D1_RENDER_TARGET_PROPERTIES
//
//------------------------------------------------------------------------------
struct D2D1_RENDER_TARGET_PROPERTIES
{
    D2D1_RENDER_TARGET_TYPE type;
    D2D1_PIXEL_FORMAT pixelFormat;
    FLOAT dpiX;
    FLOAT dpiY;
    D2D1_RENDER_TARGET_USAGE usage;
    D2D1_FEATURE_LEVEL minLevel;

}


//+-----------------------------------------------------------------------------
//
//  Struct:
//      D2D1_HWND_RENDER_TARGET_PROPERTIES
//
//------------------------------------------------------------------------------
struct D2D1_HWND_RENDER_TARGET_PROPERTIES
{
    HWND hwnd;
    D2D1_SIZE_U pixelSize;
    D2D1_PRESENT_OPTIONS presentOptions;

}


//+-----------------------------------------------------------------------------
//
//  Flag:
//      D2D1_COMPATIBLE_RENDER_TARGET_OPTIONS
//
//------------------------------------------------------------------------------
alias D2D1_COMPATIBLE_RENDER_TARGET_OPTIONS = int;
enum : D2D1_COMPATIBLE_RENDER_TARGET_OPTIONS
{
        D2D1_COMPATIBLE_RENDER_TARGET_OPTIONS_NONE = 0x00000000,
        
        //
        // The compatible render target will allow a call to GetDC on the
        // ID2D1GdiInteropRenderTarget interface. This can be specified even if the parent
        // render target is not GDI compatible.
        //
        D2D1_COMPATIBLE_RENDER_TARGET_OPTIONS_GDI_COMPATIBLE = 0x00000001,
        D2D1_COMPATIBLE_RENDER_TARGET_OPTIONS_FORCE_DWORD = 0xffffffff

}

// TODO: translate this
//DEFINE_ENUM_FLAG_OPERATORS(D2D1_COMPATIBLE_RENDER_TARGET_OPTIONS);


//+-----------------------------------------------------------------------------
//
//  Struct:
//      D2D1_DRAWING_STATE_DESCRIPTION
//
//  Synopsis:
//      Allows the drawing state to be atomically created. This also specifies the
//      drawing state that is saved into an IDrawingStateBlock object.
//
//------------------------------------------------------------------------------
struct D2D1_DRAWING_STATE_DESCRIPTION
{
    D2D1_ANTIALIAS_MODE antialiasMode;
    D2D1_TEXT_ANTIALIAS_MODE textAntialiasMode;
    D2D1_TAG tag1;
    D2D1_TAG tag2;
    D2D1_MATRIX_3X2_F transform;

}


//+-----------------------------------------------------------------------------
//
//  Enum:
//      D2D1_DC_INITIALIZE_MODE
//
//------------------------------------------------------------------------------
alias D2D1_DC_INITIALIZE_MODE = int;
enum : D2D1_DC_INITIALIZE_MODE
{
        
        //
        // The contents of the D2D render target will be copied to the DC.
        //
        D2D1_DC_INITIALIZE_MODE_COPY = 0,
        
        //
        // The contents of the DC will be cleared.
        //
        D2D1_DC_INITIALIZE_MODE_CLEAR = 1,
        D2D1_DC_INITIALIZE_MODE_FORCE_DWORD = 0xffffffff

}


//+-----------------------------------------------------------------------------
//
//  Enum:
//      D2D1_DEBUG_LEVEL
//
//  Synopsis:
//      Indicates the debug level to be output by the debug layer.
//
//------------------------------------------------------------------------------
alias D2D1_DEBUG_LEVEL = int;
enum : D2D1_DEBUG_LEVEL
{
        D2D1_DEBUG_LEVEL_NONE = 0,
        D2D1_DEBUG_LEVEL_ERROR = 1,
        D2D1_DEBUG_LEVEL_WARNING = 2,
        D2D1_DEBUG_LEVEL_INFORMATION = 3,
        D2D1_DEBUG_LEVEL_FORCE_DWORD = 0xffffffff

}


//+-----------------------------------------------------------------------------
//
//  Enum:
//      D2D1_FACTORY_TYPE
//
//  Synopsis:
//      Specifies the threading model of the created factory and all of its derived
//      resources.
//
//------------------------------------------------------------------------------
alias D2D1_FACTORY_TYPE = int;
enum : D2D1_FACTORY_TYPE
{
        
        //
        // The resulting factory and derived resources may only be invoked serially.
        // Reference counts on resources are interlocked, however, resource and render
        // target state is not protected from multi-threaded access.
        //
        D2D1_FACTORY_TYPE_SINGLE_THREADED = 0,
        
        //
        // The resulting factory may be invoked from multiple threads. Returned resources
        // use interlocked reference counting and their state is protected.
        //
        D2D1_FACTORY_TYPE_MULTI_THREADED = 1,
        D2D1_FACTORY_TYPE_FORCE_DWORD = 0xffffffff

}


//+-----------------------------------------------------------------------------
//
//  Struct:
//      D2D1_FACTORY_OPTIONS
//
//  Synopsis:
//      Allows additional parameters for factory creation.
//
//------------------------------------------------------------------------------
struct D2D1_FACTORY_OPTIONS
{
    
    //
    // Requests a certain level of debugging information from the debug layer. This
    // parameter is ignored if the debug layer DLL is not present.
    //
    D2D1_DEBUG_LEVEL debugLevel;

}


//#endif /* WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_APP) */




//#pragma region Application Family
//#if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_APP)


//+-----------------------------------------------------------------------------
//
//  Interface:
//      ID2D1Resource
//
//  Synopsis:
//      The root interface for all resources in D2D.
//
//------------------------------------------------------------------------------
mixin( uuid!(ID2D1Resource, "2cd90691-12e2-11dc-9fed-001143a055f9") );
interface ID2D1Resource : IUnknown
{
    extern(Windows):
    
    //
    // Retrieve the factory associated with this resource.
    //
    void GetFactory( ID2D1Factory* factory ) const;
} // interface ID2D1Resource



//+-----------------------------------------------------------------------------
//
//  Interface:
//      ID2D1Image
//
//------------------------------------------------------------------------------
mixin( uuid!(ID2D1Image, "65019f75-8da2-497c-b32c-dfa34e48ede6") );
interface ID2D1Image : ID2D1Resource
{
	extern(Windows):
} // interface ID2D1Image



//+-----------------------------------------------------------------------------
//
//  Interface:
//      ID2D1Bitmap
//
//  Synopsis:
//      Root bitmap resource, linearly scaled on a draw call.
//
//------------------------------------------------------------------------------
mixin( uuid!(ID2D1Bitmap, "a2296057-ea42-4099-983b-539fb6505426") );
interface ID2D1Bitmap : ID2D1Image
{
    extern(Windows):
    
    //
    // Returns the size of the bitmap in resolution independent units.
    //
	// BUG: got crash? see ID2D1RenderTarget.GetSize() 
    ref D2D1_SIZE_F GetSize() const;
    
    
    //
    // Returns the size of the bitmap in resolution dependent units, (pixels).
    //
	// BUG: got crash? see ID2D1RenderTarget.GetSize() 
	ref D2D1_SIZE_U GetPixelSize() const;
    
    
    //
    // Retrieve the format of the bitmap.
    //
	// BUG: got crash? see ID2D1RenderTarget.GetSize() 
	ref D2D1_PIXEL_FORMAT GetPixelFormat() const;
    
    
    //
    // Return the DPI of the bitmap.
    //
    void GetDpi(out FLOAT dpiX, out FLOAT dpiY ) const;
    
    HRESULT CopyFromBitmap(
        const(D2D1_POINT_2U)* destPoint,
        ID2D1Bitmap bitmap,
        const(D2D1_RECT_U)* srcRect 
        );
    
    HRESULT CopyFromRenderTarget(
        const(D2D1_POINT_2U)* destPoint,
        ID2D1RenderTarget renderTarget,
        const(D2D1_RECT_U)* srcRect 
        );
    
    HRESULT CopyFromMemory(
        const(D2D1_RECT_U)* dstRect,
        const(void*) srcData,
        UINT32 pitch
        );
} // interface ID2D1Bitmap



//+-----------------------------------------------------------------------------
//
//  Interface:
//      ID2D1GradientStopCollection
//
//  Synopsis:
//      Represents an collection of gradient stops that can then be the source resource
//      for either a linear or radial gradient brush.
//
//------------------------------------------------------------------------------
mixin( uuid!(ID2D1GradientStopCollection, "2cd906a7-12e2-11dc-9fed-001143a055f9") );
interface ID2D1GradientStopCollection : ID2D1Resource
{
    extern(Windows):
    
    //
    // Returns the number of stops in the gradient.
    //
    UINT32 GetGradientStopCount() const;
    
    
    //
    // Copies the gradient stops from the collection into the caller's interface.  The
    // returned colors have straight alpha.
    //
    void GetGradientStops(
        D2D1_GRADIENT_STOP* gradientStops,
        UINT32 gradientStopsCount 
        ) const;
    
    
    //
    // Returns whether the interpolation occurs with 1.0 or 2.2 gamma.
    //
    D2D1_GAMMA GetColorInterpolationGamma() const;
    
    D2D1_EXTEND_MODE GetExtendMode() const;
} // interface ID2D1GradientStopCollection



//+-----------------------------------------------------------------------------
//
//  Interface:
//      ID2D1Brush
//
//  Synopsis:
//      The root brush interface. All brushes can be used to fill or pen a geometry.
//
//------------------------------------------------------------------------------
mixin( uuid!(ID2D1Brush, "2cd906a8-12e2-11dc-9fed-001143a055f9") );
interface ID2D1Brush : ID2D1Resource
{
    extern(Windows):
    
    //
    // Sets the opacity for when the brush is drawn over the entire fill of the brush.
    //
    void SetOpacity( FLOAT opacity );
    
    
    //
    // Sets the transform that applies to everything drawn by the brush.
    //
    void SetTransform( const(D2D1_MATRIX_3X2_F)* transform );
    
    FLOAT GetOpacity() const;
    
    void GetTransform( /*out*/ D2D1_MATRIX_3X2_F* transform ) const;
    
    /*COM_DECLSPEC_NOTHROW
    void
    SetTransform(
        CONST D2D1_MATRIX_3X2_F &transform 
        )  
    {
        SetTransform(&transform);
    }
	*/
} // interface ID2D1Brush



//+-----------------------------------------------------------------------------
//
//  Interface:
//      ID2D1BitmapBrush
//
//  Synopsis:
//      A bitmap brush allows a bitmap to be used to fill a geometry.
//
//------------------------------------------------------------------------------
mixin( uuid!(ID2D1BitmapBrush, "2cd906aa-12e2-11dc-9fed-001143a055f9") );
interface ID2D1BitmapBrush : ID2D1Brush
{
    extern(Windows):
    
    //
    // Sets how the bitmap is to be treated outside of its natural extent on the X
    // axis.
    //
    void SetExtendModeX( D2D1_EXTEND_MODE extendModeX );
    
    
    //
    // Sets how the bitmap is to be treated outside of its natural extent on the X
    // axis.
    //
    void SetExtendModeY( D2D1_EXTEND_MODE extendModeY );
    
    
    //
    // Sets the interpolation mode used when this brush is used.
    //
    void SetInterpolationMode( D2D1_BITMAP_INTERPOLATION_MODE interpolationMode );
    
    
    //
    // Sets the bitmap associated as the source of this brush.
    //
    void SetBitmap( ID2D1Bitmap bitmap );
    
    D2D1_EXTEND_MODE GetExtendModeX() const;
    
    D2D1_EXTEND_MODE GetExtendModeY() const;
    
    D2D1_BITMAP_INTERPOLATION_MODE GetInterpolationMode() const;
    
    void GetBitmap( out ID2D1Bitmap *bitmap ) const;
} // interface ID2D1BitmapBrush



//+-----------------------------------------------------------------------------
//
//  Interface:
//      ID2D1SolidColorBrush
//
//------------------------------------------------------------------------------
mixin( uuid!(ID2D1SolidColorBrush, "2cd906a9-12e2-11dc-9fed-001143a055f9") );
interface ID2D1SolidColorBrush : ID2D1Brush
{
	extern(Windows):
    
    void SetColor( const(D2D1_COLOR_F)* color );
    
	// BUG: got crash? see ID2D1RenderTarget.GetSize() 
    ref D2D1_COLOR_F GetColor() const;
    
	/*
    COM_DECLSPEC_NOTHROW
    void
    SetColor(
        CONST D2D1_COLOR_F &color 
        )  
    {
        SetColor(&color);
    }
	*/
} // interface ID2D1SolidColorBrush



//+-----------------------------------------------------------------------------
//
//  Interface:
//      ID2D1LinearGradientBrush
//
//------------------------------------------------------------------------------
mixin( uuid!(ID2D1LinearGradientBrush, "2cd906ab-12e2-11dc-9fed-001143a055f9") );
interface ID2D1LinearGradientBrush : ID2D1Brush
{
    extern(Windows):
	
    void SetStartPoint( D2D1_POINT_2F startPoint );
    
    
    //
    // Sets the end point of the gradient in local coordinate space. This is not
    // influenced by the geometry being filled.
    //
    void SetEndPoint( D2D1_POINT_2F endPoint );
    
	// BUG: got crash? see ID2D1RenderTarget.GetSize() 
    ref D2D1_POINT_2F GetStartPoint() const;
    
	// BUG: got crash? see ID2D1RenderTarget.GetSize() 
    ref D2D1_POINT_2F GetEndPoint() const;
    
    void GetGradientStopCollection(
        /*out*/ ID2D1GradientStopCollection *gradientStopCollection 
        ) const;
} // interface ID2D1LinearGradientBrush



//+-----------------------------------------------------------------------------
//
//  Interface:
//      ID2D1RadialGradientBrush
//
//------------------------------------------------------------------------------
mixin( uuid!(ID2D1RadialGradientBrush, "2cd906ac-12e2-11dc-9fed-001143a055f9") );
interface ID2D1RadialGradientBrush : ID2D1Brush
{
    extern(Windows):
    
    //
    // Sets the center of the radial gradient. This will be in local coordinates and
    // will not depend on the geometry being filled.
    //
    void SetCenter( D2D1_POINT_2F center );
    
    
    //
    // Sets offset of the origin relative to the radial gradient center.
    //
	void SetGradientOriginOffset( D2D1_POINT_2F gradientOriginOffset );
    
    void SetRadiusX( FLOAT radiusX );
    
    void SetRadiusY( FLOAT radiusY );
    
	// BUG: got crash? see ID2D1RenderTarget.GetSize() 
    ref D2D1_POINT_2F GetCenter() const;
    
	// BUG: got crash? see ID2D1RenderTarget.GetSize() 
    ref D2D1_POINT_2F GetGradientOriginOffset() const;
    
    FLOAT GetRadiusX() const;
    
    FLOAT GetRadiusY() const;
    
    void GetGradientStopCollection(
        /*out*/ ID2D1GradientStopCollection *gradientStopCollection 
        ) const;
} // interface ID2D1RadialGradientBrush



//+-----------------------------------------------------------------------------
//
//  Interface:
//      ID2D1StrokeStyle
//
//  Synopsis:
//      Resource interface that holds pen style properties.
//
//------------------------------------------------------------------------------
mixin( uuid!(ID2D1StrokeStyle, "2cd9069d-12e2-11dc-9fed-001143a055f9") );
interface ID2D1StrokeStyle  : ID2D1Resource
{
    extern(Windows):
	
    D2D1_CAP_STYLE GetStartCap() const;
    
    D2D1_CAP_STYLE GetEndCap() const;
    
    D2D1_CAP_STYLE GetDashCap() const;
    
    FLOAT GetMiterLimit() const;
    
    D2D1_LINE_JOIN GetLineJoin() const;
    
    FLOAT GetDashOffset() const;
    
    D2D1_DASH_STYLE GetDashStyle() const;
    
    UINT32 GetDashesCount() const;
    
    /*
    //
    // Returns the dashes from the object into a user allocated array. The user must
    // call GetDashesCount to retrieve the required size.
    //
    STDMETHOD_(void, GetDashes)(
        _Out_writes_(dashesCount) FLOAT *dashes,
        UINT32 dashesCount 
        ) CONST PURE;
	*/
} // interface ID2D1StrokeStyle



//+-----------------------------------------------------------------------------
//
//  Interface:
//      ID2D1Geometry
//
//------------------------------------------------------------------------------
mixin( uuid!(ID2D1Geometry, "2cd906a1-12e2-11dc-9fed-001143a055f9") );
interface ID2D1Geometry : ID2D1Resource
{
    extern(Windows):
    
    //
    // Retrieve the bounds of the geometry, with an optional applied transform.
    //
    HRESULT GetBounds(
        const(D2D1_MATRIX_3X2_F)* worldTransform,
        /*out*/ D2D1_RECT_F* bounds 
        ) const;
    
    
    //
    // Get the bounds of the corresponding geometry after it has been widened or have
    // an optional pen style applied.
    //
    HRESULT GetWidenedBounds(
        FLOAT strokeWidth,
        ID2D1StrokeStyle strokeStyle,
        const(D2D1_MATRIX_3X2_F)* worldTransform,
        FLOAT flatteningTolerance,
        /*out*/ D2D1_RECT_F *bounds 
        ) const;
    
    
    //
    // Checks to see whether the corresponding penned and widened geometry contains the
    // given point.
    //
    HRESULT StrokeContainsPoint(
        D2D1_POINT_2F point,
        FLOAT strokeWidth,
        ID2D1StrokeStyle strokeStyle,
        const(D2D1_MATRIX_3X2_F)* worldTransform,
        FLOAT flatteningTolerance,
        /*out*/BOOL* contains 
        ) const;
    
    
    //
    // Test whether the given fill of this geometry would contain this point.
    //
    HRESULT FillContainsPoint(
        D2D1_POINT_2F point,
        const(D2D1_MATRIX_3X2_F)* worldTransform,
        FLOAT flatteningTolerance,
        /*out*/ BOOL *contains 
        ) const;
    
    
    //
    // Compare how one geometry intersects or contains another geometry.
    //
    HRESULT CompareWithGeometry(
        ID2D1Geometry inputGeometry,
        const(D2D1_MATRIX_3X2_F)* inputGeometryTransform,
        FLOAT flatteningTolerance,
        /*out*/ D2D1_GEOMETRY_RELATION *relation 
        ) const;
    
    
    //
    // Converts a geometry to a simplified geometry that has arcs and quadratic beziers
    // removed.
    //
    HRESULT Simplify(
        D2D1_GEOMETRY_SIMPLIFICATION_OPTION simplificationOption,
        const(D2D1_MATRIX_3X2_F)* worldTransform,
        FLOAT flatteningTolerance,
        ID2D1SimplifiedGeometrySink geometrySink 
        ) const;
    
    
    //
    // Tessellates a geometry into triangles.
    //
    HRESULT Tessellate(
        const(D2D1_MATRIX_3X2_F)* worldTransform,
        FLOAT flatteningTolerance,
        ID2D1TessellationSink tessellationSink 
        ) const;
    
    
    //
    // Performs a combine operation between the two geometries to produce a resulting
    // geometry.
    //
    HRESULT CombineWithGeometry(
        ID2D1Geometry inputGeometry,
        D2D1_COMBINE_MODE combineMode,
        const(D2D1_MATRIX_3X2_F)* inputGeometryTransform,
        FLOAT flatteningTolerance,
        ID2D1SimplifiedGeometrySink geometrySink 
        ) const;
    
    
    //
    // Computes the outline of the geometry. The result is written back into a
    // simplified geometry sink.
    //
    HRESULT Outline(
        const(D2D1_MATRIX_3X2_F)* worldTransform,
        FLOAT flatteningTolerance,
        ID2D1SimplifiedGeometrySink geometrySink 
        ) const;
    
    
    //
    // Computes the area of the geometry.
    //
    HRESULT ComputeArea(
        const(D2D1_MATRIX_3X2_F)* worldTransform,
        FLOAT flatteningTolerance,
        /*out*/ FLOAT *area 
        ) const;
    
    
    //
    // Computes the length of the geometry.
    //
    HRESULT ComputeLength(
        const(D2D1_MATRIX_3X2_F)* worldTransform,
        FLOAT flatteningTolerance,
        /*out*/ FLOAT *length 
        ) const;
    
    
    //
    // Computes the point and tangent a given distance along the path.
    //
    HRESULT ComputePointAtLength(
        FLOAT length,
        const(D2D1_MATRIX_3X2_F)* worldTransform,
        FLOAT flatteningTolerance,
        /*out*/ D2D1_POINT_2F *point,
        /*out*/ D2D1_POINT_2F *unitTangentVector 
        ) const;
    
    
    //
    // Get the geometry and widen it as well as apply an optional pen style.
    //
    HRESULT Widen(
        FLOAT strokeWidth,
        ID2D1StrokeStyle strokeStyle,
        const(D2D1_MATRIX_3X2_F)* worldTransform,
        FLOAT flatteningTolerance,
        ID2D1SimplifiedGeometrySink geometrySink 
        ) const;
    
    /*
    //
    // Retrieve the bounds of the geometry, with an optional applied transform.
    //
    COM_DECLSPEC_NOTHROW
    HRESULT
    GetBounds(
        CONST D2D1_MATRIX_3X2_F &worldTransform,
        _Out_ D2D1_RECT_F *bounds 
        ) CONST  
    {
        return GetBounds(&worldTransform, bounds);
    }
    
    
    //
    // Get the bounds of the corresponding geometry after it has been widened or have
    // an optional pen style applied.
    //
    COM_DECLSPEC_NOTHROW
    HRESULT
    GetWidenedBounds(
        FLOAT strokeWidth,
        _In_opt_ ID2D1StrokeStyle *strokeStyle,
        CONST D2D1_MATRIX_3X2_F &worldTransform,
        FLOAT flatteningTolerance,
        _Out_ D2D1_RECT_F *bounds 
        ) CONST  
    {
        return GetWidenedBounds(strokeWidth, strokeStyle, &worldTransform, flatteningTolerance, bounds);
    }
    
    
    //
    // Get the bounds of the corresponding geometry after it has been widened or have
    // an optional pen style applied.
    //
    COM_DECLSPEC_NOTHROW
    HRESULT
    GetWidenedBounds(
        FLOAT strokeWidth,
        _In_opt_ ID2D1StrokeStyle *strokeStyle,
        _In_opt_ CONST D2D1_MATRIX_3X2_F *worldTransform,
        _Out_ D2D1_RECT_F *bounds 
        ) CONST  
    {
        return GetWidenedBounds(strokeWidth, strokeStyle, worldTransform, D2D1_DEFAULT_FLATTENING_TOLERANCE, bounds);
    }
    
    
    //
    // Get the bounds of the corresponding geometry after it has been widened or have
    // an optional pen style applied.
    //
    COM_DECLSPEC_NOTHROW
    HRESULT
    GetWidenedBounds(
        FLOAT strokeWidth,
        _In_opt_ ID2D1StrokeStyle *strokeStyle,
        CONST D2D1_MATRIX_3X2_F &worldTransform,
        _Out_ D2D1_RECT_F *bounds 
        ) CONST  
    {
        return GetWidenedBounds(strokeWidth, strokeStyle, &worldTransform, D2D1_DEFAULT_FLATTENING_TOLERANCE, bounds);
    }
    
    COM_DECLSPEC_NOTHROW
    HRESULT
    StrokeContainsPoint(
        D2D1_POINT_2F point,
        FLOAT strokeWidth,
        _In_opt_ ID2D1StrokeStyle *strokeStyle,
        CONST D2D1_MATRIX_3X2_F &worldTransform,
        FLOAT flatteningTolerance,
        _Out_ BOOL *contains 
        ) CONST  
    {
        return StrokeContainsPoint(point, strokeWidth, strokeStyle, &worldTransform, flatteningTolerance, contains);
    }
    
    
    //
    // Checks to see whether the corresponding penned and widened geometry contains the
    // given point.
    //
    COM_DECLSPEC_NOTHROW
    HRESULT
    StrokeContainsPoint(
        D2D1_POINT_2F point,
        FLOAT strokeWidth,
        _In_opt_ ID2D1StrokeStyle *strokeStyle,
        _In_opt_ CONST D2D1_MATRIX_3X2_F *worldTransform,
        _Out_ BOOL *contains 
        ) CONST  
    {
        return StrokeContainsPoint(point, strokeWidth, strokeStyle, worldTransform, D2D1_DEFAULT_FLATTENING_TOLERANCE, contains);
    }
    
    COM_DECLSPEC_NOTHROW
    HRESULT
    StrokeContainsPoint(
        D2D1_POINT_2F point,
        FLOAT strokeWidth,
        _In_opt_ ID2D1StrokeStyle *strokeStyle,
        CONST D2D1_MATRIX_3X2_F &worldTransform,
        _Out_ BOOL *contains 
        ) CONST  
    {
        return StrokeContainsPoint(point, strokeWidth, strokeStyle, &worldTransform, D2D1_DEFAULT_FLATTENING_TOLERANCE, contains);
    }
    
    COM_DECLSPEC_NOTHROW
    HRESULT
    FillContainsPoint(
        D2D1_POINT_2F point,
        CONST D2D1_MATRIX_3X2_F &worldTransform,
        FLOAT flatteningTolerance,
        _Out_ BOOL *contains 
        ) CONST  
    {
        return FillContainsPoint(point, &worldTransform, flatteningTolerance, contains);
    }
    
    
    //
    // Test whether the given fill of this geometry would contain this point.
    //
    COM_DECLSPEC_NOTHROW
    HRESULT
    FillContainsPoint(
        D2D1_POINT_2F point,
        _In_opt_ CONST D2D1_MATRIX_3X2_F *worldTransform,
        _Out_ BOOL *contains 
        ) CONST  
    {
        return FillContainsPoint(point, worldTransform, D2D1_DEFAULT_FLATTENING_TOLERANCE, contains);
    }
    
    COM_DECLSPEC_NOTHROW
    HRESULT
    FillContainsPoint(
        D2D1_POINT_2F point,
        CONST D2D1_MATRIX_3X2_F &worldTransform,
        _Out_ BOOL *contains 
        ) CONST  
    {
        return FillContainsPoint(point, &worldTransform, D2D1_DEFAULT_FLATTENING_TOLERANCE, contains);
    }
    
    
    //
    // Compare how one geometry intersects or contains another geometry.
    //
    COM_DECLSPEC_NOTHROW
    HRESULT
    CompareWithGeometry(
        _In_ ID2D1Geometry *inputGeometry,
        CONST D2D1_MATRIX_3X2_F &inputGeometryTransform,
        FLOAT flatteningTolerance,
        _Out_ D2D1_GEOMETRY_RELATION *relation 
        ) CONST  
    {
        return CompareWithGeometry(inputGeometry, &inputGeometryTransform, flatteningTolerance, relation);
    }
    
    
    //
    // Compare how one geometry intersects or contains another geometry.
    //
    COM_DECLSPEC_NOTHROW
    HRESULT
    CompareWithGeometry(
        _In_ ID2D1Geometry *inputGeometry,
        _In_opt_ CONST D2D1_MATRIX_3X2_F *inputGeometryTransform,
        _Out_ D2D1_GEOMETRY_RELATION *relation 
        ) CONST  
    {
        return CompareWithGeometry(inputGeometry, inputGeometryTransform, D2D1_DEFAULT_FLATTENING_TOLERANCE, relation);
    }
    
    
    //
    // Compare how one geometry intersects or contains another geometry.
    //
    COM_DECLSPEC_NOTHROW
    HRESULT
    CompareWithGeometry(
        _In_ ID2D1Geometry *inputGeometry,
        CONST D2D1_MATRIX_3X2_F &inputGeometryTransform,
        _Out_ D2D1_GEOMETRY_RELATION *relation 
        ) CONST  
    {
        return CompareWithGeometry(inputGeometry, &inputGeometryTransform, D2D1_DEFAULT_FLATTENING_TOLERANCE, relation);
    }
    
    
    //
    // Converts a geometry to a simplified geometry that has arcs and quadratic beziers
    // removed.
    //
    COM_DECLSPEC_NOTHROW
    HRESULT
    Simplify(
        D2D1_GEOMETRY_SIMPLIFICATION_OPTION simplificationOption,
        CONST D2D1_MATRIX_3X2_F &worldTransform,
        FLOAT flatteningTolerance,
        _In_ ID2D1SimplifiedGeometrySink *geometrySink 
        ) CONST  
    {
        return Simplify(simplificationOption, &worldTransform, flatteningTolerance, geometrySink);
    }
    
    
    //
    // Converts a geometry to a simplified geometry that has arcs and quadratic beziers
    // removed.
    //
    COM_DECLSPEC_NOTHROW
    HRESULT
    Simplify(
        D2D1_GEOMETRY_SIMPLIFICATION_OPTION simplificationOption,
        _In_opt_ CONST D2D1_MATRIX_3X2_F *worldTransform,
        _In_ ID2D1SimplifiedGeometrySink *geometrySink 
        ) CONST  
    {
        return Simplify(simplificationOption, worldTransform, D2D1_DEFAULT_FLATTENING_TOLERANCE, geometrySink);
    }
    
    
    //
    // Converts a geometry to a simplified geometry that has arcs and quadratic beziers
    // removed.
    //
    COM_DECLSPEC_NOTHROW
    HRESULT
    Simplify(
        D2D1_GEOMETRY_SIMPLIFICATION_OPTION simplificationOption,
        CONST D2D1_MATRIX_3X2_F &worldTransform,
        _In_ ID2D1SimplifiedGeometrySink *geometrySink 
        ) CONST  
    {
        return Simplify(simplificationOption, &worldTransform, D2D1_DEFAULT_FLATTENING_TOLERANCE, geometrySink);
    }
    
    
    //
    // Tessellates a geometry into triangles.
    //
    COM_DECLSPEC_NOTHROW
    HRESULT
    Tessellate(
        CONST D2D1_MATRIX_3X2_F &worldTransform,
        FLOAT flatteningTolerance,
        _In_ ID2D1TessellationSink *tessellationSink 
        ) CONST  
    {
        return Tessellate(&worldTransform, flatteningTolerance, tessellationSink);
    }
    
    
    //
    // Tessellates a geometry into triangles.
    //
    COM_DECLSPEC_NOTHROW
    HRESULT
    Tessellate(
        _In_opt_ CONST D2D1_MATRIX_3X2_F *worldTransform,
        _In_ ID2D1TessellationSink *tessellationSink 
        ) CONST  
    {
        return Tessellate(worldTransform, D2D1_DEFAULT_FLATTENING_TOLERANCE, tessellationSink);
    }
    
    
    //
    // Tessellates a geometry into triangles.
    //
    COM_DECLSPEC_NOTHROW
    HRESULT
    Tessellate(
        CONST D2D1_MATRIX_3X2_F &worldTransform,
        _In_ ID2D1TessellationSink *tessellationSink 
        ) CONST  
    {
        return Tessellate(&worldTransform, D2D1_DEFAULT_FLATTENING_TOLERANCE, tessellationSink);
    }
    
    
    //
    // Performs a combine operation between the two geometries to produce a resulting
    // geometry.
    //
    COM_DECLSPEC_NOTHROW
    HRESULT
    CombineWithGeometry(
        _In_ ID2D1Geometry *inputGeometry,
        D2D1_COMBINE_MODE combineMode,
        CONST D2D1_MATRIX_3X2_F &inputGeometryTransform,
        FLOAT flatteningTolerance,
        _In_ ID2D1SimplifiedGeometrySink *geometrySink 
        ) CONST  
    {
        return CombineWithGeometry(inputGeometry, combineMode, &inputGeometryTransform, flatteningTolerance, geometrySink);
    }
    
    
    //
    // Performs a combine operation between the two geometries to produce a resulting
    // geometry.
    //
    COM_DECLSPEC_NOTHROW
    HRESULT
    CombineWithGeometry(
        _In_ ID2D1Geometry *inputGeometry,
        D2D1_COMBINE_MODE combineMode,
        _In_opt_ CONST D2D1_MATRIX_3X2_F *inputGeometryTransform,
        _In_ ID2D1SimplifiedGeometrySink *geometrySink 
        ) CONST  
    {
        return CombineWithGeometry(inputGeometry, combineMode, inputGeometryTransform, D2D1_DEFAULT_FLATTENING_TOLERANCE, geometrySink);
    }
    
    
    //
    // Performs a combine operation between the two geometries to produce a resulting
    // geometry.
    //
    COM_DECLSPEC_NOTHROW
    HRESULT
    CombineWithGeometry(
        _In_ ID2D1Geometry *inputGeometry,
        D2D1_COMBINE_MODE combineMode,
        CONST D2D1_MATRIX_3X2_F &inputGeometryTransform,
        _In_ ID2D1SimplifiedGeometrySink *geometrySink 
        ) CONST  
    {
        return CombineWithGeometry(inputGeometry, combineMode, &inputGeometryTransform, D2D1_DEFAULT_FLATTENING_TOLERANCE, geometrySink);
    }
    
    
    //
    // Computes the outline of the geometry. The result is written back into a
    // simplified geometry sink.
    //
    COM_DECLSPEC_NOTHROW
    HRESULT
    Outline(
        CONST D2D1_MATRIX_3X2_F &worldTransform,
        FLOAT flatteningTolerance,
        _In_ ID2D1SimplifiedGeometrySink *geometrySink 
        ) CONST  
    {
        return Outline(&worldTransform, flatteningTolerance, geometrySink);
    }
    
    
    //
    // Computes the outline of the geometry. The result is written back into a
    // simplified geometry sink.
    //
    COM_DECLSPEC_NOTHROW
    HRESULT
    Outline(
        _In_opt_ CONST D2D1_MATRIX_3X2_F *worldTransform,
        _In_ ID2D1SimplifiedGeometrySink *geometrySink 
        ) CONST  
    {
        return Outline(worldTransform, D2D1_DEFAULT_FLATTENING_TOLERANCE, geometrySink);
    }
    
    
    //
    // Computes the outline of the geometry. The result is written back into a
    // simplified geometry sink.
    //
    COM_DECLSPEC_NOTHROW
    HRESULT
    Outline(
        CONST D2D1_MATRIX_3X2_F &worldTransform,
        _In_ ID2D1SimplifiedGeometrySink *geometrySink 
        ) CONST  
    {
        return Outline(&worldTransform, D2D1_DEFAULT_FLATTENING_TOLERANCE, geometrySink);
    }
    
    
    //
    // Computes the area of the geometry.
    //
    COM_DECLSPEC_NOTHROW
    HRESULT
    ComputeArea(
        CONST D2D1_MATRIX_3X2_F &worldTransform,
        FLOAT flatteningTolerance,
        _Out_ FLOAT *area 
        ) CONST  
    {
        return ComputeArea(&worldTransform, flatteningTolerance, area);
    }
    
    
    //
    // Computes the area of the geometry.
    //
    COM_DECLSPEC_NOTHROW
    HRESULT
    ComputeArea(
        _In_opt_ CONST D2D1_MATRIX_3X2_F *worldTransform,
        _Out_ FLOAT *area 
        ) CONST  
    {
        return ComputeArea(worldTransform, D2D1_DEFAULT_FLATTENING_TOLERANCE, area);
    }
    
    
    //
    // Computes the area of the geometry.
    //
    COM_DECLSPEC_NOTHROW
    HRESULT
    ComputeArea(
        CONST D2D1_MATRIX_3X2_F &worldTransform,
        _Out_ FLOAT *area 
        ) CONST  
    {
        return ComputeArea(&worldTransform, D2D1_DEFAULT_FLATTENING_TOLERANCE, area);
    }
    
    
    //
    // Computes the length of the geometry.
    //
    COM_DECLSPEC_NOTHROW
    HRESULT
    ComputeLength(
        CONST D2D1_MATRIX_3X2_F &worldTransform,
        FLOAT flatteningTolerance,
        _Out_ FLOAT *length 
        ) CONST  
    {
        return ComputeLength(&worldTransform, flatteningTolerance, length);
    }
    
    
    //
    // Computes the length of the geometry.
    //
    COM_DECLSPEC_NOTHROW
    HRESULT
    ComputeLength(
        _In_opt_ CONST D2D1_MATRIX_3X2_F *worldTransform,
        _Out_ FLOAT *length 
        ) CONST  
    {
        return ComputeLength(worldTransform, D2D1_DEFAULT_FLATTENING_TOLERANCE, length);
    }
    
    
    //
    // Computes the length of the geometry.
    //
    COM_DECLSPEC_NOTHROW
    HRESULT
    ComputeLength(
        CONST D2D1_MATRIX_3X2_F &worldTransform,
        _Out_ FLOAT *length 
        ) CONST  
    {
        return ComputeLength(&worldTransform, D2D1_DEFAULT_FLATTENING_TOLERANCE, length);
    }
    
    
    //
    // Computes the point and tangent a given distance along the path.
    //
    COM_DECLSPEC_NOTHROW
    HRESULT
    ComputePointAtLength(
        FLOAT length,
        CONST D2D1_MATRIX_3X2_F &worldTransform,
        FLOAT flatteningTolerance,
        _Out_opt_ D2D1_POINT_2F *point,
        _Out_opt_ D2D1_POINT_2F *unitTangentVector 
        ) CONST  
    {
        return ComputePointAtLength(length, &worldTransform, flatteningTolerance, point, unitTangentVector);
    }
    
    
    //
    // Computes the point and tangent a given distance along the path.
    //
    COM_DECLSPEC_NOTHROW
    HRESULT
    ComputePointAtLength(
        FLOAT length,
        _In_opt_ CONST D2D1_MATRIX_3X2_F *worldTransform,
        _Out_opt_ D2D1_POINT_2F *point,
        _Out_opt_ D2D1_POINT_2F *unitTangentVector 
        ) CONST  
    {
        return ComputePointAtLength(length, worldTransform, D2D1_DEFAULT_FLATTENING_TOLERANCE, point, unitTangentVector);
    }
    
    
    //
    // Computes the point and tangent a given distance along the path.
    //
    COM_DECLSPEC_NOTHROW
    HRESULT
    ComputePointAtLength(
        FLOAT length,
        CONST D2D1_MATRIX_3X2_F &worldTransform,
        _Out_opt_ D2D1_POINT_2F *point,
        _Out_opt_ D2D1_POINT_2F *unitTangentVector 
        ) CONST  
    {
        return ComputePointAtLength(length, &worldTransform, D2D1_DEFAULT_FLATTENING_TOLERANCE, point, unitTangentVector);
    }
    
    
    //
    // Get the geometry and widen it as well as apply an optional pen style.
    //
    COM_DECLSPEC_NOTHROW
    HRESULT
    Widen(
        FLOAT strokeWidth,
        _In_opt_ ID2D1StrokeStyle *strokeStyle,
        CONST D2D1_MATRIX_3X2_F &worldTransform,
        FLOAT flatteningTolerance,
        _In_ ID2D1SimplifiedGeometrySink *geometrySink 
        ) CONST  
    {
        return Widen(strokeWidth, strokeStyle, &worldTransform, flatteningTolerance, geometrySink);
    }
    
    
    //
    // Get the geometry and widen it as well as apply an optional pen style.
    //
    COM_DECLSPEC_NOTHROW
    HRESULT
    Widen(
        FLOAT strokeWidth,
        _In_opt_ ID2D1StrokeStyle *strokeStyle,
        _In_opt_ CONST D2D1_MATRIX_3X2_F *worldTransform,
        _In_ ID2D1SimplifiedGeometrySink *geometrySink 
        ) CONST  
    {
        return Widen(strokeWidth, strokeStyle, worldTransform, D2D1_DEFAULT_FLATTENING_TOLERANCE, geometrySink);
    }
    
    
    //
    // Get the geometry and widen it as well as apply an optional pen style.
    //
    COM_DECLSPEC_NOTHROW
    HRESULT
    Widen(
        FLOAT strokeWidth,
        _In_opt_ ID2D1StrokeStyle *strokeStyle,
        CONST D2D1_MATRIX_3X2_F &worldTransform,
        _In_ ID2D1SimplifiedGeometrySink *geometrySink 
        ) CONST  
    {
        return Widen(strokeWidth, strokeStyle, &worldTransform, D2D1_DEFAULT_FLATTENING_TOLERANCE, geometrySink);
    }
	*/
} // interface ID2D1Geometry



//+-----------------------------------------------------------------------------
//
//  Interface:
//      ID2D1RectangleGeometry
//
//------------------------------------------------------------------------------
mixin( uuid!(ID2D1RectangleGeometry, "2cd906a2-12e2-11dc-9fed-001143a055f9") );
interface ID2D1RectangleGeometry : ID2D1Geometry
{
    extern(Windows):
    void GetRect(
        /*out*/ D2D1_RECT_F *rect 
        ) const;
} // interface ID2D1RectangleGeometry



//+-----------------------------------------------------------------------------
//
//  Interface:
//      ID2D1RoundedRectangleGeometry
//
//------------------------------------------------------------------------------
mixin( uuid!(ID2D1RoundedRectangleGeometry, "2cd906a3-12e2-11dc-9fed-001143a055f9") );
interface ID2D1RoundedRectangleGeometry : ID2D1Geometry
{
    extern(Windows):
    void GetRoundedRect(
        /*out*/ D2D1_ROUNDED_RECT *roundedRect 
        ) const;
} // interface ID2D1RoundedRectangleGeometry



//+-----------------------------------------------------------------------------
//
//  Interface:
//      ID2D1EllipseGeometry
//
//------------------------------------------------------------------------------
mixin( uuid!(ID2D1EllipseGeometry, "2cd906a4-12e2-11dc-9fed-001143a055f9") );
interface ID2D1EllipseGeometry : ID2D1Geometry
{
    extern(Windows):
    void GetEllipse(
        /*out*/ D2D1_ELLIPSE *ellipse 
        ) const;
} // interface ID2D1EllipseGeometry



//+-----------------------------------------------------------------------------
//
//  Interface:
//      ID2D1GeometryGroup
//
//------------------------------------------------------------------------------
mixin( uuid!(ID2D1GeometryGroup, "2cd906a6-12e2-11dc-9fed-001143a055f9") );
interface ID2D1GeometryGroup : ID2D1Geometry
{
    extern(Windows):
    D2D1_FILL_MODE GetFillMode() const;
    
    UINT32 GetSourceGeometryCount() const;
    
    void GetSourceGeometries(
        ID2D1Geometry* geometries,
        UINT32 geometriesCount 
        ) const;
} // interface ID2D1GeometryGroup



//+-----------------------------------------------------------------------------
//
//  Interface:
//      ID2D1TransformedGeometry
//
//------------------------------------------------------------------------------
mixin( uuid!(ID2D1TransformedGeometry, "2cd906bb-12e2-11dc-9fed-001143a055f9") );
interface ID2D1TransformedGeometry : ID2D1Geometry
{
    extern(Windows):
    void GetSourceGeometry(
        /*out*/ ID2D1Geometry* sourceGeometry 
        ) const;
    
    void GetTransform(
        /*out*/ D2D1_MATRIX_3X2_F *transform 
        ) const;
} // interface ID2D1TransformedGeometry



//+-----------------------------------------------------------------------------
//
//  Interface:
//      ID2D1SimplifiedGeometrySink
//
//------------------------------------------------------------------------------
mixin( uuid!(ID2D1SimplifiedGeometrySink, "2cd9069e-12e2-11dc-9fed-001143a055f9") );
interface ID2D1SimplifiedGeometrySink : IUnknown
{
    extern(Windows):
    void SetFillMode(
        D2D1_FILL_MODE fillMode 
        );
    
    void SetSegmentFlags(
        D2D1_PATH_SEGMENT vertexFlags 
        );
    
    void BeginFigure(
        D2D1_POINT_2F startPoint,
        D2D1_FIGURE_BEGIN figureBegin 
        );
    
    void AddLines(
        const(D2D1_POINT_2F)* points,
        UINT32 pointsCount 
        );
    
    void AddBeziers(
        const(D2D1_BEZIER_SEGMENT)* beziers,
        UINT32 beziersCount 
        );
    
    void EndFigure(
        D2D1_FIGURE_END figureEnd 
        );
    
    HRESULT Close();
} // interface ID2D1SimplifiedGeometrySink



//+-----------------------------------------------------------------------------
//
//  Interface:
//      ID2D1GeometrySink
//
//------------------------------------------------------------------------------
mixin( uuid!(ID2D1GeometrySink, "2cd9069f-12e2-11dc-9fed-001143a055f9") );
interface ID2D1GeometrySink : ID2D1SimplifiedGeometrySink
{
    extern(Windows):
    void AddLine(
        D2D1_POINT_2F point 
        );
    
    void AddBezier(
        const(D2D1_BEZIER_SEGMENT)* bezier 
        );
    
    void AddQuadraticBezier(
        const(D2D1_QUADRATIC_BEZIER_SEGMENT)* bezier 
        );
    
    void AddQuadraticBeziers(
        const(D2D1_QUADRATIC_BEZIER_SEGMENT)* beziers,
        UINT32 beziersCount 
        );
    
    void AddArc(
        const(D2D1_ARC_SEGMENT)* arc 
        );
    /*
    COM_DECLSPEC_NOTHROW
    void
    AddBezier(
        CONST D2D1_BEZIER_SEGMENT &bezier 
        )  
    {
        AddBezier(&bezier);
    }
    
    COM_DECLSPEC_NOTHROW
    void
    AddQuadraticBezier(
        CONST D2D1_QUADRATIC_BEZIER_SEGMENT &bezier 
        )  
    {
        AddQuadraticBezier(&bezier);
    }
    
    COM_DECLSPEC_NOTHROW
    void
    AddArc(
        CONST D2D1_ARC_SEGMENT &arc 
        )  
    {
        AddArc(&arc);
    }
	*/
} // interface ID2D1GeometrySink



//+-----------------------------------------------------------------------------
//
//  Interface:
//      ID2D1TessellationSink
//
//------------------------------------------------------------------------------
mixin( uuid!(ID2D1TessellationSink, "2cd906c1-12e2-11dc-9fed-001143a055f9") );
interface ID2D1TessellationSink : IUnknown
{
    extern(Windows):
    void AddTriangles(
        const(D2D1_TRIANGLE)* triangles,
        UINT32 trianglesCount 
        );
    
    HRESULT Close();
} // interface ID2D1TessellationSink



//+-----------------------------------------------------------------------------
//
//  Interface:
//      ID2D1PathGeometry
//
//------------------------------------------------------------------------------
mixin( uuid!(ID2D1PathGeometry, "2cd906a5-12e2-11dc-9fed-001143a055f9") );
interface ID2D1PathGeometry : ID2D1Geometry
{
    extern(Windows):
    
    //
    // Opens a geometry sink that will be used to create this path geometry.
    //
    HRESULT Open(
        /*out*/ ID2D1GeometrySink* geometrySink 
        );
    
    
    //
    // Retrieve the contents of this geometry. The caller passes an implementation of a
    // ID2D1GeometrySink interface to receive the data.
    //
    HRESULT Stream(
        ID2D1GeometrySink geometrySink 
        );
    
    HRESULT GetSegmentCount(
        /*out*/ UINT32 *count 
        );
    
    HRESULT GetFigureCount(
        /*out*/ UINT32 *count 
        );
} // interface ID2D1PathGeometry



//+-----------------------------------------------------------------------------
//
//  Interface:
//      ID2D1Mesh
//
//------------------------------------------------------------------------------
mixin( uuid!(ID2D1Mesh, "2cd906c2-12e2-11dc-9fed-001143a055f9") );
interface ID2D1Mesh : ID2D1Resource
{
    extern(Windows):
    
    //
    // Opens the mesh for population.
    //
    HRESULT Open(
        /*out*/ ID2D1TessellationSink* tessellationSink 
        );
} // interface ID2D1Mesh



//+-----------------------------------------------------------------------------
//
//  Interface:
//      ID2D1Layer
//
//------------------------------------------------------------------------------
mixin( uuid!(ID2D1Layer, "2cd9069b-12e2-11dc-9fed-001143a055f9") );
interface ID2D1Layer : ID2D1Resource
{
    extern(Windows):

	// BUG: got crash? see ID2D1RenderTarget.GetSize() 
    ref D2D1_SIZE_F GetSize() const;

} // interface ID2D1Layer



//+-----------------------------------------------------------------------------
//
//  Interface:
//      ID2D1DrawingStateBlock
//
//------------------------------------------------------------------------------
mixin( uuid!(ID2D1DrawingStateBlock, "28506e39-ebf6-46a1-bb47-fd85565ab957") );
interface ID2D1DrawingStateBlock : ID2D1Resource
{
    extern(Windows):
    
    //
    // Retrieves the state currently contained within this state block resource.
    //
    void GetDescription(
        /*out*/ D2D1_DRAWING_STATE_DESCRIPTION *stateDescription 
        ) const;
    
    
    //
    // Sets the state description of this state block resource.
    //
    void SetDescription(
        const(D2D1_DRAWING_STATE_DESCRIPTION)* stateDescription
        );
    
    
    //
    // Sets the text rendering parameters of this state block resource.
    //
    void SetTextRenderingParams(
        IDWriteRenderingParams textRenderingParams = null 
        );
    
    
    //
    // Retrieves the text rendering parameters contained within this state block
    // resource. If a NULL text rendering parameter was specified, NULL will be
    // returned.
    //
    void GetTextRenderingParams(
        /*out*/ IDWriteRenderingParams* textRenderingParams 
        ) const;
    
	/*
    COM_DECLSPEC_NOTHROW
    void
    SetDescription(
        CONST D2D1_DRAWING_STATE_DESCRIPTION &stateDescription 
        )  
    {
        SetDescription(&stateDescription);
    }
	*/
} // interface ID2D1DrawingStateBlock



//+-----------------------------------------------------------------------------
//
//  Interface:
//      ID2D1RenderTarget
//
//------------------------------------------------------------------------------
mixin( uuid!(ID2D1RenderTarget, "2cd90694-12e2-11dc-9fed-001143a055f9") );
interface ID2D1RenderTarget : ID2D1Resource
{
    extern(Windows):
    
    //
    // Create a D2D bitmap by copying from memory, or create uninitialized.
    //
    HRESULT CreateBitmap(
        D2D1_SIZE_U size,
        const(void*) srcData,
        UINT32 pitch,
        const(D2D1_BITMAP_PROPERTIES)* bitmapProperties,
        /*out*/ID2D1Bitmap* bitmap 
        );
    
    
    //
    // Create a D2D bitmap by copying a WIC bitmap.
    //
    HRESULT CreateBitmapFromWicBitmap(
        IWICBitmapSource wicBitmapSource,
        const(D2D1_BITMAP_PROPERTIES)* bitmapProperties,
        /*out*/ ID2D1Bitmap *bitmap 
        );
    
    
    //
    // Create a D2D bitmap by sharing bits from another resource. The bitmap must be
    // compatible with the render target for the call to succeed.
    // For example, an IWICBitmap can be shared with a software target, or a DXGI
    // surface can be shared with a DXGI render target.
    //
    HRESULT CreateSharedBitmap(
        REFIID riid,
        void *data,
        const(D2D1_BITMAP_PROPERTIES)* bitmapProperties,
        /*out*/ ID2D1Bitmap* bitmap
        );
    
    
    //
    // Creates a bitmap brush. The bitmap is scaled, rotated, skewed or tiled to fill
    // or pen a geometry.
    //
    HRESULT CreateBitmapBrush(
        ID2D1Bitmap bitmap,
        const(D2D1_BITMAP_BRUSH_PROPERTIES)* bitmapBrushProperties,
        const(D2D1_BRUSH_PROPERTIES)* brushProperties,
        /*out*/ ID2D1BitmapBrush* bitmapBrush 
        );
    
    HRESULT CreateSolidColorBrush(
        const(D2D1_COLOR_F)* color,
        const(D2D1_BRUSH_PROPERTIES)* brushProperties,
        /*out*/ ID2D1SolidColorBrush* solidColorBrush 
        );
    
    
    //
    // A gradient stop collection represents a set of stops in an ideal unit length.
    // This is the source resource for a linear gradient and radial gradient brush.
    //
    HRESULT CreateGradientStopCollection(
        const(D2D1_GRADIENT_STOP)* gradientStops,
        UINT32 gradientStopsCount,
        
        //
        // Specifies which space the color interpolation occurs in.
        //
        D2D1_GAMMA colorInterpolationGamma,
        
        //
        // Specifies how the gradient will be extended outside of the unit length.
        //
        D2D1_EXTEND_MODE extendMode,
        /*out*/ ID2D1GradientStopCollection* gradientStopCollection 
        );
    
    HRESULT CreateLinearGradientBrush(
        const(D2D1_LINEAR_GRADIENT_BRUSH_PROPERTIES)* linearGradientBrushProperties,
        const(D2D1_BRUSH_PROPERTIES)* brushProperties,
        ID2D1GradientStopCollection gradientStopCollection,
        /*out*/ ID2D1LinearGradientBrush* linearGradientBrush 
        );
    
    HRESULT CreateRadialGradientBrush(
        const(D2D1_RADIAL_GRADIENT_BRUSH_PROPERTIES)* radialGradientBrushProperties,
        const(D2D1_BRUSH_PROPERTIES)* brushProperties,
        ID2D1GradientStopCollection gradientStopCollection,
        /*out*/ ID2D1RadialGradientBrush* radialGradientBrush
        );
    
    
    //
    // Creates a bitmap render target whose bitmap can be used as a source for
    // rendering in the API.
    //
    HRESULT CreateCompatibleRenderTarget(
        
        //
        // The requested size of the target in DIPs. If the pixel size is not specified,
        // the DPI is inherited from the parent target. However, the render target will
        // never contain a fractional number of pixels.
        //
        const(D2D1_SIZE_F)* desiredSize,
        
        //
        // The requested size of the render target in pixels. If the DIP size is also
        // specified, the DPI is calculated from these two values. If the desired size is
        // not specified, the DPI is inherited from the parent render target. If neither
        // value is specified, the compatible render target will be the same size and have
        // the same DPI as the parent target.
        //
        const(D2D1_SIZE_U)* desiredPixelSize,
        
        //
        // The desired pixel format. The format must be compatible with the parent render
        // target type. If the format is not specified, it will be inherited from the
        // parent render target.
        //
        const(D2D1_PIXEL_FORMAT)* desiredFormat,
        
        //
        // Allows the caller to retrieve a GDI compatible render target.
        //
        D2D1_COMPATIBLE_RENDER_TARGET_OPTIONS options,
        
        //
        // The returned bitmap render target.
        //
        /*out*/ ID2D1BitmapRenderTarget* bitmapRenderTarget 
        );
    
    
    //
    // Creates a layer resource that can be used on any target and which will resize
    // under the covers if necessary.
    //
    HRESULT CreateLayer(
        
        //
        // The resolution independent minimum size hint for the layer resource. Specify
        // this to prevent unwanted reallocation of the layer backing store. The size is in
        // DIPs, but, it is unaffected by the current world transform. If the size is
        // unspecified, the returned resource is a placeholder and the backing store will
        // be allocated to be the minimum size that can hold the content when the layer is
        // pushed.
        //
        const(D2D1_SIZE_F)* size,
        /*out*/ ID2D1Layer* layer 
        );
    
    
    //
    // Create a D2D mesh.
    //
    HRESULT CreateMesh(
        /*out*/ ID2D1Mesh* mesh 
        );
    
    void DrawLine(
        D2D1_POINT_2F point0,
        D2D1_POINT_2F point1,
        ID2D1Brush brush,
        FLOAT strokeWidth = 1.0f,
        ID2D1StrokeStyle strokeStyle = null 
        );
    
    void DrawRectangle(
        const(D2D1_RECT_F)* rect,
        ID2D1Brush brush,
        FLOAT strokeWidth = 1.0f,
        ID2D1StrokeStyle strokeStyle = null 
        );
    
    void FillRectangle(
        const(D2D1_RECT_F)* rect,
        ID2D1Brush brush 
        );
    
    void DrawRoundedRectangle(
        const(D2D1_ROUNDED_RECT)* roundedRect,
        ID2D1Brush brush,
        FLOAT strokeWidth = 1.0f,
        ID2D1StrokeStyle strokeStyle = null
        );
    
    void FillRoundedRectangle(
        const(D2D1_ROUNDED_RECT)* roundedRect,
        ID2D1Brush brush 
        );
    
    void DrawEllipse(
        const(D2D1_ELLIPSE)* ellipse,
        ID2D1Brush brush,
        FLOAT strokeWidth = 1.0f,
        ID2D1StrokeStyle strokeStyle = null 
        );
    
    void FillEllipse(
        const(D2D1_ELLIPSE)* ellipse,
        ID2D1Brush brush 
        );
    
    void DrawGeometry(
        ID2D1Geometry geometry,
        ID2D1Brush brush,
        FLOAT strokeWidth = 1.0f,
        ID2D1StrokeStyle strokeStyle = null
        );
    
    void FillGeometry(
        ID2D1Geometry geometry,
        ID2D1Brush brush,
        
        //
        // An optionally specified opacity brush. Only the alpha channel of the
        // corresponding brush will be sampled and will be applied to the entire fill of
        // the geometry. If this brush is specified, the fill brush must be a bitmap brush
        // with an extend mode of D2D1_EXTEND_MODE_CLAMP.
        //
        ID2D1Brush opacityBrush = null
        );
    
    
    //
    // Fill a mesh. Since meshes can only render aliased content, the render target
    // antialiasing mode must be set to aliased.
    //
    void FillMesh(
        ID2D1Mesh mesh,
        ID2D1Brush brush 
        );
    
    
    //
    // Fill using the alpha channel of the supplied opacity mask bitmap. The brush
    // opacity will be modulated by the mask. The render target antialiasing mode must
    // be set to aliased.
    //
    void FillOpacityMask(
        ID2D1Bitmap opacityMask,
        ID2D1Brush brush,
        D2D1_OPACITY_MASK_CONTENT content,
        const(D2D1_RECT_F)* destinationRectangle = null,
        const(D2D1_RECT_F)* sourceRectangle = null 
        );
    
    void DrawBitmap(
        ID2D1Bitmap bitmap,
        const(D2D1_RECT_F)* destinationRectangle = null,
        FLOAT opacity = 1.0f,
        D2D1_BITMAP_INTERPOLATION_MODE interpolationMode = D2D1_BITMAP_INTERPOLATION_MODE_LINEAR,
        const(D2D1_RECT_F)* sourceRectangle = null 
        );
    
    
    //
    // Draws the text within the given layout rectangle and by default also snaps and
    // clips it to the content bounds.
    //
    void DrawText(
        const(WCHAR)* string,
        UINT32 stringLength,
        IDWriteTextFormat textFormat,
        const(D2D1_RECT_F)* layoutRect,
        ID2D1Brush defaultForegroundBrush,
        D2D1_DRAW_TEXT_OPTIONS options = D2D1_DRAW_TEXT_OPTIONS_NONE,
        DWRITE_MEASURING_MODE measuringMode = DWRITE_MEASURING_MODE_NATURAL 
        );
    
    
    //
    // Draw a snapped text layout object. Since the layout is not subsequently changed,
    // this can be more efficient than DrawText when drawing the same layout
    // repeatedly.
    //
    void DrawTextLayout(
        D2D1_POINT_2F origin,
        IDWriteTextLayout textLayout,
        ID2D1Brush defaultForegroundBrush,
        
        //
        // The specified text options. NOTE: By default the text is clipped to the layout
        // bounds. This is derived from the origin and the layout bounds of the
        // corresponding IDWriteTextLayout object.
        //
        D2D1_DRAW_TEXT_OPTIONS options = D2D1_DRAW_TEXT_OPTIONS_NONE 
        );
    
    void DrawGlyphRun(
        D2D1_POINT_2F baselineOrigin,
        const(DWRITE_GLYPH_RUN)* glyphRun,
        ID2D1Brush foregroundBrush,
        DWRITE_MEASURING_MODE measuringMode = DWRITE_MEASURING_MODE_NATURAL 
        );
    
    void SetTransform(
        const(D2D1_MATRIX_3X2_F)* transform 
        );
    
    void GetTransform(
        /*out*/ D2D1_MATRIX_3X2_F* transform 
        ) const;
    
    void SetAntialiasMode(
        D2D1_ANTIALIAS_MODE antialiasMode 
        );
    
    D2D1_ANTIALIAS_MODE GetAntialiasMode() const;
    
    void SetTextAntialiasMode(
        D2D1_TEXT_ANTIALIAS_MODE textAntialiasMode 
        );
    
    D2D1_TEXT_ANTIALIAS_MODE GetTextAntialiasMode() const;
    
    void SetTextRenderingParams(
        IDWriteRenderingParams textRenderingParams = null 
        );
    
    
    //
    // Retrieve the text render parameters. NOTE: If NULL is specified to
    // SetTextRenderingParameters, NULL will be returned.
    //
    void GetTextRenderingParams(
        /*out*/ IDWriteRenderingParams* textRenderingParams 
        ) const;
    
    
    //
    // Set a tag to correspond to the succeeding primitives. If an error occurs
    // rendering a primitive, the tags can be returned from the Flush or EndDraw call.
    //
    void SetTags(
        D2D1_TAG tag1,
        D2D1_TAG tag2 
        );
    
    
    //
    // Retrieves the currently set tags. This does not retrieve the tags corresponding
    // to any primitive that is in error.
    //
    void GetTags(
        /*out*/ D2D1_TAG *tag1 = null,
        /*out*/ D2D1_TAG *tag2 = null 
        ) const;
    
    
    //
    // Start a layer of drawing calls. The way in which the layer must be resolved is
    // specified first as well as the logical resource that stores the layer
    // parameters. The supplied layer resource might grow if the specified content
    // cannot fit inside it. The layer will grow monotonically on each axis.  If a NULL
    // ID2D1Layer is provided, then a layer resource will be allocated automatically.
    //
    void PushLayer(
        const(D2D1_LAYER_PARAMETERS)* layerParameters,
        ID2D1Layer layer 
        );
    
    
    //
    // Ends a layer that was defined with particular layer resources.
    //
    void PopLayer();
    
    HRESULT Flush(
        /*out*/ D2D1_TAG *tag1 = null,
        /*out*/ D2D1_TAG *tag2 = null 
        );
    
    
    //
    // Gets the current drawing state and saves it into the supplied
    // IDrawingStatckBlock.
    //
    void SaveDrawingState(
        /*inout*/ ref ID2D1DrawingStateBlock drawingStateBlock 
        ) const;
    
    
    //
    // Copies the state stored in the block interface.
    //
    void RestoreDrawingState(
        ID2D1DrawingStateBlock drawingStateBlock 
        );
    
    
    //
    // Pushes a clip. The clip can be antialiased. The clip must be axis aligned. If
    // the current world transform is not axis preserving, then the bounding box of the
    // transformed clip rect will be used. The clip will remain in effect until a
    // PopAxisAligned clip call is made.
    //
    void PushAxisAlignedClip(
        const(D2D1_RECT_F)* clipRect,
        D2D1_ANTIALIAS_MODE antialiasMode 
        );
    
    void PopAxisAlignedClip();
    
    void Clear(
        const(D2D1_COLOR_F)* clearColor = null 
        );
    
    
    //
    // Start drawing on this render target. Draw calls can only be issued between a
    // BeginDraw and EndDraw call.
    //
    void BeginDraw();
    
    
    //
    // Ends drawing on the render target, error results can be retrieved at this time,
    // or when calling flush.
    //
    HRESULT EndDraw(
        /*out*/ D2D1_TAG *tag1 = null,
        /*out*/ D2D1_TAG *tag2 = null 
        );
    
version(CORRECT_ABI)
	D2D1_PIXEL_FORMAT GetPixelFormat() const;
else
    void GetPixelFormat(D2D1_PIXEL_FORMAT* outPixelFormat) const; // <-- NOTE: ABI bug workaround, see D2D1_PIXEL_FORMAT GetPixelFormat() below
    
    
    //
    // Sets the DPI on the render target. This results in the render target being
    // interpreted to a different scale. Neither DPI can be negative. If zero is
    // specified for both, the system DPI is chosen. If one is zero and the other
    // unspecified, the DPI is not changed.
    //
    void SetDpi(
        FLOAT dpiX,
        FLOAT dpiY 
        );
    
    
    //
    // Return the current DPI from the target.
    //
    void GetDpi(
        /*out*/ FLOAT *dpiX,
        /*out*/ FLOAT *dpiY 
        ) const;
    
    
    //
    // Returns the size of the render target in DIPs.
    //
version(CORRECT_ABI)
	D2D1_SIZE_F GetSize() const;
else
    void GetSize(D2D1_SIZE_F* outSize) const; // <-- NOTE: ABI bug workaround, see D2D1_SIZE_F GetSize() below
    
    
    //
    // Returns the size of the render target in pixels.
    //
version(CORRECT_ABI)
	D2D1_SIZE_U GetPixelSize() const;
else
    void GetPixelSize(D2D1_SIZE_U* outSize) const; // <-- NOTE: ABI bug workaround, see D2D1_SIZE_U GetPixelSize() below
    
    
    //
    // Returns the maximum bitmap and render target size that is guaranteed to be
    // supported by the render target.
    //
    UINT32 GetMaximumBitmapSize() const;
    
    
    //
    // Returns true if the given properties are supported by this render target. The
    // DPI is ignored. NOTE: If the render target type is software, then neither
    // D2D1_FEATURE_LEVEL_9 nor D2D1_FEATURE_LEVEL_10 will be considered to be
    // supported.
    //
    BOOL IsSupported(
        const(D2D1_RENDER_TARGET_PROPERTIES)* renderTargetProperties 
        ) const;
    
	/*
    COM_DECLSPEC_NOTHROW
    HRESULT
    CreateBitmap(
        D2D1_SIZE_U size,
        _In_opt_ CONST void *srcData,
        UINT32 pitch,
        CONST D2D1_BITMAP_PROPERTIES &bitmapProperties,
        _Outptr_ ID2D1Bitmap **bitmap 
        )  
    {
        return CreateBitmap(size, srcData, pitch, &bitmapProperties, bitmap);
    }
    
    COM_DECLSPEC_NOTHROW
    HRESULT
    CreateBitmap(
        D2D1_SIZE_U size,
        CONST D2D1_BITMAP_PROPERTIES &bitmapProperties,
        _Outptr_ ID2D1Bitmap **bitmap 
        )  
    {
        return CreateBitmap(size, NULL, 0, &bitmapProperties, bitmap);
    }
    
    
    //
    // Create a D2D bitmap by copying a WIC bitmap.
    //
    COM_DECLSPEC_NOTHROW
    HRESULT
    CreateBitmapFromWicBitmap(
        _In_ IWICBitmapSource *wicBitmapSource,
        CONST D2D1_BITMAP_PROPERTIES &bitmapProperties,
        _Outptr_ ID2D1Bitmap **bitmap 
        )  
    {
        return CreateBitmapFromWicBitmap(wicBitmapSource, &bitmapProperties, bitmap);
    }
    
    
    //
    // Create a D2D bitmap by copying a WIC bitmap.
    //
    COM_DECLSPEC_NOTHROW
    HRESULT
    CreateBitmapFromWicBitmap(
        _In_ IWICBitmapSource *wicBitmapSource,
        _Outptr_ ID2D1Bitmap **bitmap 
        )  
    {
        return CreateBitmapFromWicBitmap(wicBitmapSource, NULL, bitmap);
    }
    
    
    //
    // Creates a bitmap brush. The bitmap is scaled, rotated, skewed or tiled to fill
    // or pen a geometry.
    //
    COM_DECLSPEC_NOTHROW
    HRESULT
    CreateBitmapBrush(
        _In_opt_ ID2D1Bitmap *bitmap,
        _Outptr_ ID2D1BitmapBrush **bitmapBrush 
        )  
    {
        return CreateBitmapBrush(bitmap, NULL, NULL, bitmapBrush);
    }
    
    
    //
    // Creates a bitmap brush. The bitmap is scaled, rotated, skewed or tiled to fill
    // or pen a geometry.
    //
    COM_DECLSPEC_NOTHROW
    HRESULT
    CreateBitmapBrush(
        _In_opt_ ID2D1Bitmap *bitmap,
        CONST D2D1_BITMAP_BRUSH_PROPERTIES &bitmapBrushProperties,
        _Outptr_ ID2D1BitmapBrush **bitmapBrush 
        )  
    {
        return CreateBitmapBrush(bitmap, &bitmapBrushProperties, NULL, bitmapBrush);
    }
    
    
    //
    // Creates a bitmap brush. The bitmap is scaled, rotated, skewed or tiled to fill
    // or pen a geometry.
    //
    COM_DECLSPEC_NOTHROW
    HRESULT
    CreateBitmapBrush(
        _In_opt_ ID2D1Bitmap *bitmap,
        CONST D2D1_BITMAP_BRUSH_PROPERTIES &bitmapBrushProperties,
        CONST D2D1_BRUSH_PROPERTIES &brushProperties,
        _Outptr_ ID2D1BitmapBrush **bitmapBrush 
        )  
    {
        return CreateBitmapBrush(bitmap, &bitmapBrushProperties, &brushProperties, bitmapBrush);
    }


    HRESULT
    CreateSolidColorBrush(
        const(D2D1_COLOR_F) color,
        /+out+/ ID2D1SolidColorBrush* solidColorBrush 
        )  
    {
        return CreateSolidColorBrush(&color, null, solidColorBrush);
    }

    
    COM_DECLSPEC_NOTHROW
    HRESULT
    CreateSolidColorBrush(
        CONST D2D1_COLOR_F &color,
        CONST D2D1_BRUSH_PROPERTIES &brushProperties,
        _Outptr_ ID2D1SolidColorBrush **solidColorBrush 
        )  
    {
        return CreateSolidColorBrush(&color, &brushProperties, solidColorBrush);
    }
    
    COM_DECLSPEC_NOTHROW
    HRESULT
    CreateGradientStopCollection(
        _In_reads_(gradientStopsCount) CONST D2D1_GRADIENT_STOP *gradientStops,
        UINT32 gradientStopsCount,
        _Outptr_ ID2D1GradientStopCollection **gradientStopCollection 
        )  
    {
        return CreateGradientStopCollection(gradientStops, gradientStopsCount, D2D1_GAMMA_2_2, D2D1_EXTEND_MODE_CLAMP, gradientStopCollection);
    }
    
    COM_DECLSPEC_NOTHROW
    HRESULT
    CreateLinearGradientBrush(
        CONST D2D1_LINEAR_GRADIENT_BRUSH_PROPERTIES &linearGradientBrushProperties,
        _In_ ID2D1GradientStopCollection *gradientStopCollection,
        _Outptr_ ID2D1LinearGradientBrush **linearGradientBrush 
        )  
    {
        return CreateLinearGradientBrush(&linearGradientBrushProperties, NULL, gradientStopCollection, linearGradientBrush);
    }
    
    COM_DECLSPEC_NOTHROW
    HRESULT
    CreateLinearGradientBrush(
        CONST D2D1_LINEAR_GRADIENT_BRUSH_PROPERTIES &linearGradientBrushProperties,
        CONST D2D1_BRUSH_PROPERTIES &brushProperties,
        _In_ ID2D1GradientStopCollection *gradientStopCollection,
        _Outptr_ ID2D1LinearGradientBrush **linearGradientBrush 
        )  
    {
        return CreateLinearGradientBrush(&linearGradientBrushProperties, &brushProperties, gradientStopCollection, linearGradientBrush);
    }
    
    COM_DECLSPEC_NOTHROW
    HRESULT
    CreateRadialGradientBrush(
        CONST D2D1_RADIAL_GRADIENT_BRUSH_PROPERTIES &radialGradientBrushProperties,
        _In_ ID2D1GradientStopCollection *gradientStopCollection,
        _Outptr_ ID2D1RadialGradientBrush **radialGradientBrush 
        )  
    {
        return CreateRadialGradientBrush(&radialGradientBrushProperties, NULL, gradientStopCollection, radialGradientBrush);
    }
    
    COM_DECLSPEC_NOTHROW
    HRESULT
    CreateRadialGradientBrush(
        CONST D2D1_RADIAL_GRADIENT_BRUSH_PROPERTIES &radialGradientBrushProperties,
        CONST D2D1_BRUSH_PROPERTIES &brushProperties,
        _In_ ID2D1GradientStopCollection *gradientStopCollection,
        _Outptr_ ID2D1RadialGradientBrush **radialGradientBrush 
        )  
    {
        return CreateRadialGradientBrush(&radialGradientBrushProperties, &brushProperties, gradientStopCollection, radialGradientBrush);
    }
    
    COM_DECLSPEC_NOTHROW
    HRESULT
    CreateCompatibleRenderTarget(
        _Outptr_ ID2D1BitmapRenderTarget **bitmapRenderTarget 
        )  
    {
        return CreateCompatibleRenderTarget(NULL, NULL, NULL, D2D1_COMPATIBLE_RENDER_TARGET_OPTIONS_NONE, bitmapRenderTarget);
    }
    
    COM_DECLSPEC_NOTHROW
    HRESULT
    CreateCompatibleRenderTarget(
        D2D1_SIZE_F desiredSize,
        _Outptr_ ID2D1BitmapRenderTarget **bitmapRenderTarget 
        )  
    {
        return CreateCompatibleRenderTarget(&desiredSize, NULL, NULL, D2D1_COMPATIBLE_RENDER_TARGET_OPTIONS_NONE, bitmapRenderTarget);
    }
    
    COM_DECLSPEC_NOTHROW
    HRESULT
    CreateCompatibleRenderTarget(
        D2D1_SIZE_F desiredSize,
        D2D1_SIZE_U desiredPixelSize,
        _Outptr_ ID2D1BitmapRenderTarget **bitmapRenderTarget 
        )  
    {
        return CreateCompatibleRenderTarget(&desiredSize, &desiredPixelSize, NULL, D2D1_COMPATIBLE_RENDER_TARGET_OPTIONS_NONE, bitmapRenderTarget);
    }
    
    COM_DECLSPEC_NOTHROW
    HRESULT
    CreateCompatibleRenderTarget(
        D2D1_SIZE_F desiredSize,
        D2D1_SIZE_U desiredPixelSize,
        D2D1_PIXEL_FORMAT desiredFormat,
        _Outptr_ ID2D1BitmapRenderTarget **bitmapRenderTarget 
        )  
    {
        return CreateCompatibleRenderTarget(&desiredSize, &desiredPixelSize, &desiredFormat, D2D1_COMPATIBLE_RENDER_TARGET_OPTIONS_NONE, bitmapRenderTarget);
    }
    
    COM_DECLSPEC_NOTHROW
    HRESULT
    CreateCompatibleRenderTarget(
        D2D1_SIZE_F desiredSize,
        D2D1_SIZE_U desiredPixelSize,
        D2D1_PIXEL_FORMAT desiredFormat,
        D2D1_COMPATIBLE_RENDER_TARGET_OPTIONS options,
        _Outptr_ ID2D1BitmapRenderTarget **bitmapRenderTarget 
        )  
    {
        return CreateCompatibleRenderTarget(&desiredSize, &desiredPixelSize, &desiredFormat, options, bitmapRenderTarget);
    }
    
    COM_DECLSPEC_NOTHROW
    HRESULT
    CreateLayer(
        D2D1_SIZE_F size,
        _Outptr_ ID2D1Layer **layer 
        )  
    {
        return CreateLayer(&size, layer);
    }
    
    COM_DECLSPEC_NOTHROW
    HRESULT
    CreateLayer(
        _Outptr_ ID2D1Layer **layer 
        )  
    {
        return CreateLayer(NULL, layer);
    }
    
    COM_DECLSPEC_NOTHROW
    void
    DrawRectangle(
        CONST D2D1_RECT_F &rect,
        _In_ ID2D1Brush *brush,
        FLOAT strokeWidth = 1.0f,
        _In_opt_ ID2D1StrokeStyle *strokeStyle = NULL 
        )  
    {
        DrawRectangle(&rect, brush, strokeWidth, strokeStyle);
    }
    
    COM_DECLSPEC_NOTHROW
    void
    FillRectangle(
        CONST D2D1_RECT_F &rect,
        _In_ ID2D1Brush *brush 
        )  
    {
        FillRectangle(&rect, brush);
    }
    
    COM_DECLSPEC_NOTHROW
    void
    DrawRoundedRectangle(
        CONST D2D1_ROUNDED_RECT &roundedRect,
        _In_ ID2D1Brush *brush,
        FLOAT strokeWidth = 1.0f,
        _In_opt_ ID2D1StrokeStyle *strokeStyle = NULL 
        )  
    {
        DrawRoundedRectangle(&roundedRect, brush, strokeWidth, strokeStyle);
    }
    
    COM_DECLSPEC_NOTHROW
    void
    FillRoundedRectangle(
        CONST D2D1_ROUNDED_RECT &roundedRect,
        _In_ ID2D1Brush *brush 
        )  
    {
        FillRoundedRectangle(&roundedRect, brush);
    }
    
    COM_DECLSPEC_NOTHROW
    void
    DrawEllipse(
        CONST D2D1_ELLIPSE &ellipse,
        _In_ ID2D1Brush *brush,
        FLOAT strokeWidth = 1.0f,
        _In_opt_ ID2D1StrokeStyle *strokeStyle = NULL 
        )  
    {
        DrawEllipse(&ellipse, brush, strokeWidth, strokeStyle);
    }
    
    COM_DECLSPEC_NOTHROW
    void
    FillEllipse(
        CONST D2D1_ELLIPSE &ellipse,
        _In_ ID2D1Brush *brush 
        )  
    {
        FillEllipse(&ellipse, brush);
    }
    
    COM_DECLSPEC_NOTHROW
    void
    FillOpacityMask(
        _In_ ID2D1Bitmap *opacityMask,
        _In_ ID2D1Brush *brush,
        D2D1_OPACITY_MASK_CONTENT content,
        CONST D2D1_RECT_F &destinationRectangle,
        CONST D2D1_RECT_F &sourceRectangle 
        )  
    {
        FillOpacityMask(opacityMask, brush, content, &destinationRectangle, &sourceRectangle);
    }
    
    COM_DECLSPEC_NOTHROW
    void
    DrawBitmap(
        _In_ ID2D1Bitmap *bitmap,
        CONST D2D1_RECT_F &destinationRectangle,
        FLOAT opacity = 1.0f,
        D2D1_BITMAP_INTERPOLATION_MODE interpolationMode = D2D1_BITMAP_INTERPOLATION_MODE_LINEAR,
        _In_opt_ CONST D2D1_RECT_F *sourceRectangle = NULL 
        )  
    {
        DrawBitmap(bitmap, &destinationRectangle, opacity, interpolationMode, sourceRectangle);
    }
    
    COM_DECLSPEC_NOTHROW
    void
    DrawBitmap(
        _In_ ID2D1Bitmap *bitmap,
        CONST D2D1_RECT_F &destinationRectangle,
        FLOAT opacity,
        D2D1_BITMAP_INTERPOLATION_MODE interpolationMode,
        CONST D2D1_RECT_F &sourceRectangle 
        )  
    {
        DrawBitmap(bitmap, &destinationRectangle, opacity, interpolationMode, &sourceRectangle);
    }
    
    COM_DECLSPEC_NOTHROW
    void
    SetTransform(
        CONST D2D1_MATRIX_3X2_F &transform 
        )  
    {
        SetTransform(&transform);
    }
    
    COM_DECLSPEC_NOTHROW
    void
    PushLayer(
        CONST D2D1_LAYER_PARAMETERS &layerParameters,
        _In_opt_ ID2D1Layer *layer 
        )  
    {
        PushLayer(&layerParameters, layer);
    }
    
    COM_DECLSPEC_NOTHROW
    void
    PushAxisAlignedClip(
        CONST D2D1_RECT_F &clipRect,
        D2D1_ANTIALIAS_MODE antialiasMode 
        )  
    {
        return PushAxisAlignedClip(&clipRect, antialiasMode);
    }
    
    COM_DECLSPEC_NOTHROW
    void
    Clear(
        CONST D2D1_COLOR_F &clearColor 
        )  
    {
        return Clear(&clearColor);
    }
    
    
    //
    // Draws the text within the given layout rectangle and by default also snaps and
    // clips it.
    //
    COM_DECLSPEC_NOTHROW
    void
    DrawText(
        _In_reads_(stringLength) CONST WCHAR *string,
        UINT32 stringLength,
        _In_ IDWriteTextFormat *textFormat,
        CONST D2D1_RECT_F &layoutRect,
        _In_ ID2D1Brush *defaultForegroundBrush,
        D2D1_DRAW_TEXT_OPTIONS options = D2D1_DRAW_TEXT_OPTIONS_NONE,
        DWRITE_MEASURING_MODE measuringMode = DWRITE_MEASURING_MODE_NATURAL 
        )  
    {
        return DrawText(string, stringLength, textFormat, &layoutRect, defaultForegroundBrush, options, measuringMode);
    }
    
    COM_DECLSPEC_NOTHROW
    BOOL
    IsSupported(
        CONST D2D1_RENDER_TARGET_PROPERTIES &renderTargetProperties 
        ) CONST  
    {
        return IsSupported(&renderTargetProperties);
    }
	*/

	// =================================================================
	//    HELPER METHODS

version(CORRECT_ABI) {}
else:

	// ABI bug workaround for ID2D1RenderTarget.GetPixelFormat() related to return struct by value
	public final D2D1_PIXEL_FORMAT GetPixelFormat() const
	{
		D2D1_PIXEL_FORMAT pFormat;
		this.GetPixelFormat(&pFormat);
		return pFormat;
	}

	// ABI bug workaround for ID2D1RenderTarget.GetSize() related to return struct by value
	public final D2D1_SIZE_F GetSize() const
	{
		D2D1_SIZE_F rtSize;
		this.GetSize(&rtSize);
		return rtSize;
	}

	// ABI bug workaround for ID2D1RenderTarget.GetPixelSize() related to return struct by value
	public final D2D1_SIZE_U GetPixelSize() const
	{
		D2D1_SIZE_U pSize;
		this.GetPixelSize(&pSize);
		return pSize;
	}

} // interface ID2D1RenderTarget



//+-----------------------------------------------------------------------------
//
//  Interface:
//      ID2D1BitmapRenderTarget
//
//------------------------------------------------------------------------------
mixin( uuid!(ID2D1BitmapRenderTarget, "2cd90695-12e2-11dc-9fed-001143a055f9") );
interface ID2D1BitmapRenderTarget : ID2D1RenderTarget
{
    extern(Windows):
    HRESULT GetBitmap(
        /*out*/ ID2D1Bitmap* bitmap 
        );
} // interface ID2D1BitmapRenderTarget



//+-----------------------------------------------------------------------------
//
//  Interface:
//      ID2D1HwndRenderTarget
//
//------------------------------------------------------------------------------
mixin( uuid!(ID2D1HwndRenderTarget, "2cd90698-12e2-11dc-9fed-001143a055f9") );
interface ID2D1HwndRenderTarget : ID2D1RenderTarget
{
    extern(Windows):
    D2D1_WINDOW_STATE CheckWindowState();
    
    
    //
    // Resize the buffer underlying the render target. This operation might fail if
    // there is insufficient video memory or system memory, or if the render target is
    // resized beyond the maximum bitmap size. If the method fails, the render target
    // will be placed in a zombie state and D2DERR_RECREATE_TARGET will be returned
    // from it when EndDraw is called. In addition an appropriate failure result will
    // be returned from Resize.
    //
    HRESULT Resize(
        const(D2D1_SIZE_U)* pixelSize 
        );
    
    HWND GetHwnd() const;
    
	/*
    COM_DECLSPEC_NOTHROW
    HRESULT
    Resize(
        CONST D2D1_SIZE_U &pixelSize 
        )  
    {
        return Resize(&pixelSize);
    }
	*/
} // interface ID2D1HwndRenderTarget




//+-----------------------------------------------------------------------------
//
//  Interface:
//      ID2D1GdiInteropRenderTarget
//
//------------------------------------------------------------------------------
mixin( uuid!(ID2D1GdiInteropRenderTarget, "e0db51c3-6f77-4bae-b3d5-e47509b35838") );
interface ID2D1GdiInteropRenderTarget : IUnknown
{
    extern(Windows):
    HRESULT GetDC(
        D2D1_DC_INITIALIZE_MODE mode,
        /*out*/HDC *hdc 
        );
    
    HRESULT ReleaseDC(
        const(RECT)* update 
        );
} // interface ID2D1GdiInteropRenderTarget



//+-----------------------------------------------------------------------------
//
//  Interface:
//      ID2D1DCRenderTarget
//
//------------------------------------------------------------------------------
mixin( uuid!(ID2D1DCRenderTarget, "1c51bc64-de61-46fd-9899-63a5d8f03950") );
interface ID2D1DCRenderTarget : ID2D1RenderTarget
{
    extern(Windows):
    HRESULT BindDC(
        const HDC  hDC,
        const(RECT)* pSubRect 
        );
} // interface ID2D1DCRenderTarget



//+-----------------------------------------------------------------------------
//
//  Interface:
//      ID2D1Factory
//
//  Synopsis:
//      The root factory interface for all of D2D's objects.
//
//------------------------------------------------------------------------------
mixin( uuid!(ID2D1Factory, "06152247-6f50-465a-9245-118bfd3b6007") );
interface ID2D1Factory : IUnknown
{
    extern(Windows):
    
    //
    // Cause the factory to refresh any system metrics that it might have been snapped
    // on factory creation.
    //
    HRESULT ReloadSystemMetrics();
    
    
    //
    // Retrieves the current desktop DPI. To refresh this, call ReloadSystemMetrics.
    //
    void GetDesktopDpi(
        /*out*/ FLOAT *dpiX,
        /*out*/ FLOAT *dpiY 
        );
    
    HRESULT CreateRectangleGeometry(
        const(D2D1_RECT_F)* rectangle,
        /*out*/ ID2D1RectangleGeometry* rectangleGeometry 
        );
    
    HRESULT CreateRoundedRectangleGeometry(
        const(D2D1_ROUNDED_RECT)* roundedRectangle,
        /*out*/ ID2D1RoundedRectangleGeometry* roundedRectangleGeometry 
        );
    
    HRESULT CreateEllipseGeometry(
        const(D2D1_ELLIPSE)* ellipse,
        /*out*/ ID2D1EllipseGeometry* ellipseGeometry 
        );
    
    
    //
    // Create a geometry which holds other geometries.
    //
    HRESULT CreateGeometryGroup(
        D2D1_FILL_MODE fillMode,
        /*in*/ ID2D1Geometry *geometries,
        UINT32 geometriesCount,
        /*out*/ ID2D1GeometryGroup *geometryGroup 
        );
    
    HRESULT CreateTransformedGeometry(
        ID2D1Geometry sourceGeometry,
        const(D2D1_MATRIX_3X2_F)* transform,
        /*out*/ ID2D1TransformedGeometry* transformedGeometry 
        );
    
    
    //
    // Returns an initially empty path geometry interface. A geometry sink is created
    // off the interface to populate it.
    //
    HRESULT CreatePathGeometry(
        /*out*/ ID2D1PathGeometry* pathGeometry 
        );
    
    
    //
    // Allows a non-default stroke style to be specified for a given geometry at draw
    // time.
    //
    HRESULT CreateStrokeStyle(
        const(D2D1_STROKE_STYLE_PROPERTIES)* strokeStyleProperties,
        const(FLOAT)* dashes,
        UINT32 dashesCount,
        /*out*/ ID2D1StrokeStyle* strokeStyle 
        );
    
    
    //
    // Creates a new drawing state block, this can be used in subsequent
    // SaveDrawingState and RestoreDrawingState operations on the render target.
    //
    HRESULT CreateDrawingStateBlock(
        const(D2D1_DRAWING_STATE_DESCRIPTION)* drawingStateDescription,
        IDWriteRenderingParams textRenderingParams,
        /*out*/ ID2D1DrawingStateBlock* drawingStateBlock 
		);
    
    
    //
    // Creates a render target which is a source of bitmaps.
    //
    HRESULT CreateWicBitmapRenderTarget(
        IWICBitmap target,
        const(D2D1_RENDER_TARGET_PROPERTIES)* renderTargetProperties,
        /*out*/ ID2D1RenderTarget* renderTarget 
        );
    
    
    //
    // Creates a render target that appears on the display.
    //
    HRESULT CreateHwndRenderTarget(
        const(D2D1_RENDER_TARGET_PROPERTIES)* renderTargetProperties,
        const(D2D1_HWND_RENDER_TARGET_PROPERTIES)* hwndRenderTargetProperties,
        /*out*/ ID2D1HwndRenderTarget* hwndRenderTarget 
        );
    
    
    //
    // Creates a render target that draws to a DXGI Surface. The device that owns the
    // surface is used for rendering.
    //
    HRESULT CreateDxgiSurfaceRenderTarget(
        IDXGISurface dxgiSurface,
        const(D2D1_RENDER_TARGET_PROPERTIES)* renderTargetProperties,
        /*out*/ ID2D1RenderTarget* renderTarget 
        );
    
    
    //
    // Creates a render target that draws to a GDI device context.
    //
    HRESULT CreateDCRenderTarget(
        const(D2D1_RENDER_TARGET_PROPERTIES)* renderTargetProperties,
        /*out*/ ID2D1DCRenderTarget* dcRenderTarget 
        );
    
	/*
    COM_DECLSPEC_NOTHROW
    HRESULT
    CreateRectangleGeometry(
        CONST D2D1_RECT_F &rectangle,
        _Outptr_ ID2D1RectangleGeometry **rectangleGeometry 
        )  
    {
        return CreateRectangleGeometry(&rectangle, rectangleGeometry);
    }
    
    COM_DECLSPEC_NOTHROW
    HRESULT
    CreateRoundedRectangleGeometry(
        CONST D2D1_ROUNDED_RECT &roundedRectangle,
        _Outptr_ ID2D1RoundedRectangleGeometry **roundedRectangleGeometry 
        )  
    {
        return CreateRoundedRectangleGeometry(&roundedRectangle, roundedRectangleGeometry);
    }
    
    COM_DECLSPEC_NOTHROW
    HRESULT
    CreateEllipseGeometry(
        CONST D2D1_ELLIPSE &ellipse,
        _Outptr_ ID2D1EllipseGeometry **ellipseGeometry 
        )  
    {
        return CreateEllipseGeometry(&ellipse, ellipseGeometry);
    }
    
    COM_DECLSPEC_NOTHROW
    HRESULT
    CreateTransformedGeometry(
        _In_ ID2D1Geometry *sourceGeometry,
        CONST D2D1_MATRIX_3X2_F &transform,
        _Outptr_ ID2D1TransformedGeometry **transformedGeometry 
        )  
    {
        return CreateTransformedGeometry(sourceGeometry, &transform, transformedGeometry);
    }
    
    COM_DECLSPEC_NOTHROW
    HRESULT
    CreateStrokeStyle(
        CONST D2D1_STROKE_STYLE_PROPERTIES &strokeStyleProperties,
        _In_reads_opt_(dashesCount) CONST FLOAT *dashes,
        UINT32 dashesCount,
        _Outptr_ ID2D1StrokeStyle **strokeStyle 
        )  
    {
        return CreateStrokeStyle(&strokeStyleProperties, dashes, dashesCount, strokeStyle);
    }
    
    COM_DECLSPEC_NOTHROW
    HRESULT
    CreateDrawingStateBlock(
        CONST D2D1_DRAWING_STATE_DESCRIPTION &drawingStateDescription,
        _Outptr_ ID2D1DrawingStateBlock **drawingStateBlock 
        )  
    {
        return CreateDrawingStateBlock(&drawingStateDescription, NULL, drawingStateBlock);
    }
    
    COM_DECLSPEC_NOTHROW
    HRESULT
    CreateDrawingStateBlock(
        _Outptr_ ID2D1DrawingStateBlock **drawingStateBlock 
        )  
    {
        return CreateDrawingStateBlock(NULL, NULL, drawingStateBlock);
    }
    
    COM_DECLSPEC_NOTHROW
    HRESULT
    CreateWicBitmapRenderTarget(
        _In_ IWICBitmap *target,
        CONST D2D1_RENDER_TARGET_PROPERTIES &renderTargetProperties,
        _Outptr_ ID2D1RenderTarget **renderTarget 
        )  
    {
        return CreateWicBitmapRenderTarget(target, &renderTargetProperties, renderTarget);
    }
    
    COM_DECLSPEC_NOTHROW
    HRESULT
    CreateHwndRenderTarget(
        CONST D2D1_RENDER_TARGET_PROPERTIES &renderTargetProperties,
        CONST D2D1_HWND_RENDER_TARGET_PROPERTIES &hwndRenderTargetProperties,
        _Outptr_ ID2D1HwndRenderTarget **hwndRenderTarget 
        )  
    {
        return CreateHwndRenderTarget(&renderTargetProperties, &hwndRenderTargetProperties, hwndRenderTarget);
    }
    
    COM_DECLSPEC_NOTHROW
    HRESULT
    CreateDxgiSurfaceRenderTarget(
        _In_ IDXGISurface *dxgiSurface,
        CONST D2D1_RENDER_TARGET_PROPERTIES &renderTargetProperties,
        _Outptr_ ID2D1RenderTarget **renderTarget 
        )  
    {
        return CreateDxgiSurfaceRenderTarget(dxgiSurface, &renderTargetProperties, renderTarget);
    }
	*/
} // interface ID2D1Factory

//__gshared _D2D1CreateFactory      D2D1CreateFactory;
//__gshared _D2D1MakeRotateMatrix   D2D1MakeRotateMatrix;
//__gshared _D2D1MakeSkewMatrix     D2D1MakeSkewMatrix;
//__gshared _D2D1IsMatrixInvertible D2D1IsMatrixInvertible;
//__gshared _D2D1InvertMatrix       D2D1InvertMatrix;

extern(Windows)
HRESULT D2D1CreateFactory(D2D1_FACTORY_TYPE factoryType,
                                                REFIID riid,
                                                const(D2D1_FACTORY_OPTIONS)* pFactoryOptions,
                                                /*out*/ void **ppIFactory);
extern(Windows)
void D2D1MakeRotateMatrix(FLOAT angle,
                                                D2D1_POINT_2F center,
                                                /*out*/ D2D1_MATRIX_3X2_F *matrix);


extern(Windows)
void D2D1MakeSkewMatrix(FLOAT angleX,
                                              FLOAT angleY,
                                              D2D1_POINT_2F center,
                                              /*out*/ D2D1_MATRIX_3X2_F *matrix);

extern(Windows)
BOOL D2D1IsMatrixInvertible(const(D2D1_MATRIX_3X2_F)* matrix);

extern(Windows)
BOOL D2D1InvertMatrix(/*inout*/ D2D1_MATRIX_3X2_F* matrix);

// TODO: should this extern be removed?
extern(Windows) {
    //
    // This export cannot be in a namespace because compiler name mangling isn't consistent
    // also, this must be 'C' callable.
    //
    alias _D2D1CreateFactory = extern(Windows) HRESULT function(D2D1_FACTORY_TYPE factoryType,
                                                REFIID riid,
                                                const(D2D1_FACTORY_OPTIONS)* pFactoryOptions,
                                                /*out*/ void **ppIFactory);

    alias _D2D1MakeRotateMatrix = extern(Windows) void function(FLOAT angle,
                                                D2D1_POINT_2F center,
                                                /*out*/ D2D1_MATRIX_3X2_F *matrix);

    alias _D2D1MakeSkewMatrix = extern(Windows) void function(FLOAT angleX,
                                              FLOAT angleY,
                                              D2D1_POINT_2F center,
                                              /*out*/ D2D1_MATRIX_3X2_F *matrix);

    alias _D2D1IsMatrixInvertible = extern(Windows) BOOL function(const(D2D1_MATRIX_3X2_F)* matrix);

    alias _D2D1InvertMatrix = extern(Windows) BOOL function(/*inout*/ D2D1_MATRIX_3X2_F* matrix);
}
/+
HRESULT
D2D1CreateFactory(
    D2D1_FACTORY_TYPE factoryType,
    REFIID riid,
    /*out*/ void **factory
    )
{
    return
        D2D1CreateFactory(
            factoryType,
            riid,
            null,
            factory);
}


HRESULT
	D2D1CreateFactory(Factory)(
    D2D1_FACTORY_TYPE factoryType,
    /*out*/ Factory* factory
    )
{
    return
        D2D1CreateFactory(
            factoryType,
            mixin("&IID_"~Factory.stringof),
            cast(void**)factory);
}

HRESULT
D2D1CreateFactory(Factory)(
     D2D1_FACTORY_TYPE factoryType,
     const(D2D1_FACTORY_OPTIONS)* factoryOptions,
     /*out*/ Factory* ppFactory
    )
{
    return
        D2D1CreateFactory(
            factoryType,
			mixin("IID_"~Factory.stringof),
            factoryOptions,
            cast(void**)ppFactory);
}
+/


// ---------- EXTENSION METHODS

HRESULT
	CreateSolidColorBrush(
		ID2D1RenderTarget rt,
		const(D2D1_COLOR_F) color,
		/+out+/ ID2D1SolidColorBrush* solidColorBrush 
		)  
{
	return rt.CreateSolidColorBrush(&color, null, solidColorBrush);
}

HRESULT
	CreateSolidColorBrush(
		ID2D1HwndRenderTarget hrt,
		const(D2D1_COLOR_F) color,
		/+out+/ ID2D1SolidColorBrush* solidColorBrush 
		)  
{
	return hrt.CreateSolidColorBrush(&color, null, solidColorBrush);
}
