module directx.d2d1effectauthor;
//---------------------------------------------------------------------------
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
// This file is automatically generated.  Please do not edit it directly.
//
// File name: D2D1EffectAuthor.h
//---------------------------------------------------------------------------

version(Windows):

public import directx.d2d1_1;

public import directx.com;

/// <summary>
/// Function pointer that sets a property on an effect.
/// </summary>
alias PD2D1_PROPERTY_SET_FUNCTION = extern(Windows) HRESULT function(IUnknown effect, const(BYTE)* data, UINT32 dataSize);

/// <summary>
/// Function pointer that gets a property from an effect.
/// </summary>
alias PD2D1_PROPERTY_GET_FUNCTION = extern(Windows) HRESULT function(const IUnknown effect, BYTE* data, UINT32 dataSize, UINT32* actualSize);

/// <summary>
/// Indicates what has changed since the last time the effect was asked to prepare
/// to render.
/// </summary>
alias D2D1_CHANGE_TYPE = uint;
enum : D2D1_CHANGE_TYPE
{

    /// <summary>
    /// Nothing has changed.
    /// </summary>
    D2D1_CHANGE_TYPE_NONE = 0,
    
    /// <summary>
    /// The effect's properties have changed.
    /// </summary>
    D2D1_CHANGE_TYPE_PROPERTIES = 1,
    
    /// <summary>
    /// The internal context has changed and should be inspected.
    /// </summary>
    D2D1_CHANGE_TYPE_CONTEXT = 2,
    
    /// <summary>
    /// A new graph has been set due to a change in the input count.
    /// </summary>
    D2D1_CHANGE_TYPE_GRAPH = 3
}


/// <summary>
/// Indicates options for drawing using a pixel shader.
/// </summary>
alias D2D1_PIXEL_OPTIONS = uint;
enum : D2D1_PIXEL_OPTIONS
{
    
    /// <summary>
    /// Default pixel processing.
    /// </summary>
    D2D1_PIXEL_OPTIONS_NONE = 0,
    
    /// <summary>
    /// Indicates that the shader samples its inputs only at exactly the same scene
    /// coordinate as the output pixel, and that it returns transparent black whenever
    /// the input pixels are also transparent black.
    /// </summary>
    D2D1_PIXEL_OPTIONS_TRIVIAL_SAMPLING = 1
}


/// <summary>
/// Indicates options for drawing custom vertices set by transforms.
/// </summary>
alias D2D1_VERTEX_OPTIONS = uint;
enum : D2D1_VERTEX_OPTIONS
{
    
    /// <summary>
    /// Default vertex processing.
    /// </summary>
    D2D1_VERTEX_OPTIONS_NONE = 0,
    
    /// <summary>
    /// Indicates that the output rectangle does not need to be cleared before drawing
    /// custom vertices. This must only be used by transforms whose custom vertices
    /// completely cover their output rectangle.
    /// </summary>
    D2D1_VERTEX_OPTIONS_DO_NOT_CLEAR = 1,
    
    /// <summary>
    /// Causes a depth buffer to be used while drawing custom vertices. This impacts
    /// drawing behavior when primitives overlap one another.
    /// </summary>
    D2D1_VERTEX_OPTIONS_USE_DEPTH_BUFFER = 2,
    
    /// <summary>
    /// Indicates that custom vertices do not form primitives which overlap one another.
    /// </summary>
    D2D1_VERTEX_OPTIONS_ASSUME_NO_OVERLAP = 4
}


/// <summary>
/// Describes how a vertex buffer is to be managed.
/// </summary>
alias D2D1_VERTEX_USAGE = uint;
enum : D2D1_VERTEX_USAGE
{
    
    /// <summary>
    /// The vertex buffer content do not change frequently from frame to frame.
    /// </summary>
    D2D1_VERTEX_USAGE_STATIC = 0,
    
    /// <summary>
    /// The vertex buffer is intended to be updated frequently.
    /// </summary>
    D2D1_VERTEX_USAGE_DYNAMIC = 1

}


/// <summary>
/// Describes a particular blend in the D2D1_BLEND_DESCRIPTION structure.
/// </summary>
alias D2D1_BLEND_OPERATION = uint;
enum : D2D1_BLEND_OPERATION
{
    D2D1_BLEND_OPERATION_ADD = 1,
    D2D1_BLEND_OPERATION_SUBTRACT = 2,
    D2D1_BLEND_OPERATION_REV_SUBTRACT = 3,
    D2D1_BLEND_OPERATION_MIN = 4,
    D2D1_BLEND_OPERATION_MAX = 5
}


/// <summary>
/// Describes a particular blend in the D2D1_BLEND_DESCRIPTION structure.
/// </summary>
alias D2D1_BLEND = uint;
enum : D2D1_BLEND
{
    D2D1_BLEND_ZERO = 1,
    D2D1_BLEND_ONE = 2,
    D2D1_BLEND_SRC_COLOR = 3,
    D2D1_BLEND_INV_SRC_COLOR = 4,
    D2D1_BLEND_SRC_ALPHA = 5,
    D2D1_BLEND_INV_SRC_ALPHA = 6,
    D2D1_BLEND_DEST_ALPHA = 7,
    D2D1_BLEND_INV_DEST_ALPHA = 8,
    D2D1_BLEND_DEST_COLOR = 9,
    D2D1_BLEND_INV_DEST_COLOR = 10,
    D2D1_BLEND_SRC_ALPHA_SAT = 11,
    D2D1_BLEND_BLEND_FACTOR = 14,
    D2D1_BLEND_INV_BLEND_FACTOR = 15
}


/// <summary>
/// Allows a caller to control the channel depth of a stage in the rendering
/// pipeline.
/// </summary>
alias D2D1_CHANNEL_DEPTH = uint;
enum : D2D1_CHANNEL_DEPTH
{
    D2D1_CHANNEL_DEPTH_DEFAULT = 0,
    D2D1_CHANNEL_DEPTH_1 = 1,
    D2D1_CHANNEL_DEPTH_4 = 4
}


/// <summary>
/// Represents filtering modes transforms may select to use on their input textures.
/// </summary>
alias D2D1_FILTER = uint;
enum : D2D1_FILTER
{
    D2D1_FILTER_MIN_MAG_MIP_POINT = 0x00,
    D2D1_FILTER_MIN_MAG_POINT_MIP_LINEAR = 0x01,
    D2D1_FILTER_MIN_POINT_MAG_LINEAR_MIP_POINT = 0x04,
    D2D1_FILTER_MIN_POINT_MAG_MIP_LINEAR = 0x05,
    D2D1_FILTER_MIN_LINEAR_MAG_MIP_POINT = 0x10,
    D2D1_FILTER_MIN_LINEAR_MAG_POINT_MIP_LINEAR = 0x11,
    D2D1_FILTER_MIN_MAG_LINEAR_MIP_POINT = 0x14,
    D2D1_FILTER_MIN_MAG_MIP_LINEAR = 0x15,
    D2D1_FILTER_ANISOTROPIC = 0x55
}


/// <summary>
/// Defines capabilities of the underlying D3D device which may be queried using
/// CheckFeatureSupport.
/// </summary>
alias D2D1_FEATURE = uint;
enum : D2D1_FEATURE
{
    D2D1_FEATURE_DOUBLES = 0,
    D2D1_FEATURE_D3D10_X_HARDWARE_OPTIONS = 1
}


/// <summary>
/// Defines a property binding to a function. The name must match the property
/// defined in the registration schema.
/// </summary>
struct D2D1_PROPERTY_BINDING
{
    
    /// <summary>
    /// The name of the property.
    /// </summary>
    PCWSTR propertyName;
    
    /// <summary>
    /// The function that will receive the data to set.
    /// </summary>
    PD2D1_PROPERTY_SET_FUNCTION setFunction;
    
    /// <summary>
    /// The function that will be asked to write the output data.
    /// </summary>
    PD2D1_PROPERTY_GET_FUNCTION getFunction;
}


/// <summary>
/// This is used to define a resource texture when that resource texture is created.
/// </summary>
struct D2D1_RESOURCE_TEXTURE_PROPERTIES
{
    const(UINT32)* extents;
    UINT32 dimensions;
    D2D1_BUFFER_PRECISION bufferPrecision;
    D2D1_CHANNEL_DEPTH channelDepth;
    D2D1_FILTER filter;
    const(D2D1_EXTEND_MODE)* extendModes;
}


/// <summary>
/// This defines a single element of the vertex layout.
/// </summary>
struct D2D1_INPUT_ELEMENT_DESC
{
    PCSTR semanticName;
    UINT32 semanticIndex;
    DXGI_FORMAT format;
    UINT32 inputSlot;
    UINT32 alignedByteOffset;
}


// 
// Set to alignedByteOffset within D2D1_INPUT_ELEMENT_DESC for elements that 
// immediately follow preceding elements in memory
//
enum D2D1_APPEND_ALIGNED_ELEMENT = 0xffffffff;


/// <summary>
/// This defines the properties of a vertex buffer which uses the default vertex
/// layout.
/// </summary>
struct D2D1_VERTEX_BUFFER_PROPERTIES
{
    UINT32 inputCount;
    D2D1_VERTEX_USAGE usage;
    const(BYTE)* data;
    UINT32 byteWidth;
}


/// <summary>
/// This defines the input layout of vertices and the vertex shader which processes
/// them.
/// </summary>
struct D2D1_CUSTOM_VERTEX_BUFFER_PROPERTIES
{
    const(BYTE)* shaderBufferWithInputSignature;
    UINT32 shaderBufferSize;
    const(D2D1_INPUT_ELEMENT_DESC)* inputElements;
    UINT32 elementCount;
    UINT32 stride;
}


/// <summary>
/// This defines the range of vertices from a vertex buffer to draw.
/// </summary>
struct D2D1_VERTEX_RANGE
{
    UINT32 startVertex;
    UINT32 vertexCount;
}


/// <summary>
/// Blend description which configures a blend transform object.
/// </summary>
struct D2D1_BLEND_DESCRIPTION
{
    D2D1_BLEND sourceBlend;
    D2D1_BLEND destinationBlend;
    D2D1_BLEND_OPERATION blendOperation;
    D2D1_BLEND sourceBlendAlpha;
    D2D1_BLEND destinationBlendAlpha;
    D2D1_BLEND_OPERATION blendOperationAlpha;
    FLOAT[4] blendFactor;
};


/// <summary>
/// Describes options transforms may select to use on their input textures.
/// </summary>
struct D2D1_INPUT_DESCRIPTION
{
    D2D1_FILTER filter;
    UINT32 levelOfDetailCount;
}


/// <summary>
/// Indicates whether shader support for doubles is present on the underlying
/// hardware.  This may be populated using CheckFeatureSupport.
/// </summary>
struct D2D1_FEATURE_DATA_DOUBLES
{
    BOOL doublePrecisionFloatShaderOps;
}


/// <summary>
/// Indicates support for features which are optional on D3D10 feature levels.  This
/// may be populated using CheckFeatureSupport.
/// </summary>
struct D2D1_FEATURE_DATA_D3D10_X_HARDWARE_OPTIONS
{
    BOOL computeShaders_Plus_RawAndStructuredBuffers_Via_Shader_4_x;
}

mixin(uuid!(ID2D1VertexBuffer, "9b8b1336-00a5-4668-92b7-ced5d8bf9b7b"));
/// <summary>
/// A transform uses this interface to write new vertices to a vertex buffer.
/// </summary>
interface ID2D1VertexBuffer : IUnknown
{
	extern(Windows):
    HRESULT Map(
    	BYTE** data,
        UINT32 bufferSize 
        );
    
    HRESULT Unmap();
} // interface ID2D1VertexBuffer

mixin(uuid!(ID2D1ResourceTexture, "688d15c3-02b0-438d-b13a-d1b44c32c39a"));
interface ID2D1ResourceTexture : IUnknown
{
	extern(Windows):
    /// <summary>
    /// Update the vertex text.
    /// </summary>
    HRESULT Update(
        const(UINT32)* minimumExtents,
        const(UINT32)* maximimumExtents,
        const(UINT32)* strides,
        UINT32 dimensions,
        const(BYTE)* data,
        UINT32 dataCount 
        );
} // interface ID2D1ResourceTexture


mixin(uuid!(ID2D1RenderInfo, "519ae1bd-d19a-420d-b849-364f594776b7"));
/// <summary>
/// A transform uses this interface to specify how to render a particular pass in
/// D2D.
/// </summary>
interface ID2D1RenderInfo : IUnknown
{
	extern(Windows):
    /// <summary>
    /// Sets options for sampling the specified image input
    /// </summary>
    HRESULT SetInputDescription(
        UINT32 inputIndex,
        D2D1_INPUT_DESCRIPTION inputDescription 
        );
    
    /// <summary>
    /// Controls the output precision and channel-depth for the associated transform.
    /// </summary>
    HRESULT SetOutputBuffer(
        D2D1_BUFFER_PRECISION bufferPrecision,
        D2D1_CHANNEL_DEPTH channelDepth 
        );
    
    /// <summary>
    /// Controls whether the output of the associated transform is cached.
    /// </summary>
    void SetCached(BOOL isCached);
    
    /// <summary>
    /// Provides a hint of the approximate shader instruction count per pixel.  If
    /// provided, it may improve performance when processing large images.  Instructions
    /// should be counted multiple times if occurring within loops.
    /// </summary>
    void SetInstructionCountHint(UINT32 instructionCount);
} // interface ID2D1RenderInfo


mixin(uuid!(ID2D1DrawInfo, "693ce632-7f2f-45de-93fe-18d88b37aa21"));
/// <summary>
/// A transform uses this interface to specify how to render a particular pass using
/// pixel and vertex shaders.
/// </summary>
interface ID2D1DrawInfo : ID2D1RenderInfo
{
	extern(Windows):
    /// <summary>
    /// Set the constant buffer for this transform's pixel shader.
    /// </summary>
    HRESULT SetPixelShaderConstantBuffer(
        const(BYTE)* buffer,
        UINT32 bufferCount 
        );
    
    /// <summary>
    /// Sets the resource texture corresponding to the given shader texture index.
    /// </summary>
    HRESULT SetResourceTexture(
        UINT32 textureIndex,
        ID2D1ResourceTexture resourceTexture 
        );
    
    /// <summary>
    /// Set the constant buffer for this transform's vertex shader.
    /// </summary>
    HRESULT SetVertexShaderConstantBuffer(
        const(BYTE)* buffer,
        UINT32 bufferCount 
        );
    
    /// <summary>
    /// Set the shader instructions for this transform.
    /// </summary>
    HRESULT SetPixelShader(
        REFGUID shaderId,
        D2D1_PIXEL_OPTIONS pixelOptions = D2D1_PIXEL_OPTIONS_NONE 
        );
    
    /// <summary>
    /// Set custom vertices for the associated transform.  A blend mode if
    /// foreground-over will be used if blendDescription is null.
    /// </summary>
    HRESULT SetVertexProcessing(
        ID2D1VertexBuffer vertexBuffer,
        D2D1_VERTEX_OPTIONS vertexOptions,
        const(D2D1_BLEND_DESCRIPTION)* blendDescription = null,
        const(D2D1_VERTEX_RANGE)* vertexRange = null,
        const(GUID)* vertexShader = null 
        );
} // interface ID2D1DrawInfo


mixin(uuid!(ID2D1ComputeInfo, "5598b14b-9fd7-48b7-9bdb-8f0964eb38bc"));
/// <summary>
/// A transform uses this interface to specify how to render a particular pass using
/// compute shader.
/// </summary>
interface ID2D1ComputeInfo : ID2D1RenderInfo
{
	extern(Windows):
    /// <summary>
    /// Set the constant buffer for this transform.
    /// </summary>
    HRESULT SetComputeShaderConstantBuffer(
        const(BYTE)* buffer,
        UINT32 bufferCount 
        );
    
    /// <summary>
    /// Set the shader instructions for this transform.
    /// </summary>
    HRESULT SetComputeShader(REFGUID shaderId);
    
    /// <summary>
    /// Sets the resource texture corresponding to the given shader texture index.
    /// </summary>
    HRESULT SetResourceTexture(
        UINT32 textureIndex,
        ID2D1ResourceTexture resourceTexture 
        );
} // interface ID2D1ComputeInfo


mixin(uuid!(ID2D1TransformNode, "b2efe1e7-729f-4102-949f-505fa21bf666"));
/// <summary>
/// A base object which can be inserted into a transform graph.
/// </summary>
interface ID2D1TransformNode : IUnknown
{
	extern(Windows):
    /// <summary>
    /// Return the number of input this node has.
    /// </summary>
    UINT32 GetInputCount() const;
} // interface ID2D1TransformNode


mixin(uuid!(ID2D1TransformGraph, "13d29038-c3e6-4034-9081-13b53a417992"));
/// <summary>
/// The implementation of the actual graph.
/// </summary>
interface ID2D1TransformGraph : IUnknown
{
	extern(Windows):
    /// <summary>
    /// Return the number of input this graph has.
    /// </summary>
    UINT32 GetInputCount() const;
    
    /// <summary>
    /// Sets the graph to contain a single transform whose inputs map 1:1 with effect
    /// inputs.
    /// </summary>
    HRESULT SetSingleTransformNode(ID2D1TransformNode node);
    
    /// <summary>
    /// Adds the given transform node to the graph.
    /// </summary>
    HRESULT AddNode(ID2D1TransformNode node);
    
    /// <summary>
    /// Removes the given transform node from the graph.
    /// </summary>
    HRESULT RemoveNode(ID2D1TransformNode node);
    
    /// <summary>
    /// Indicates that the given transform node should be considered to be the output
    /// node of the graph.
    /// </summary>
    HRESULT SetOutputNode(ID2D1TransformNode node);
    
    /// <summary>
    /// Connects one node to another node inside the graph.
    /// </summary>
    HRESULT ConnectNode(
        ID2D1TransformNode fromNode,
        ID2D1TransformNode toNode,
        UINT32 toNodeInputIndex 
        );
    
    /// <summary>
    /// Connects a transform node inside the graph to the corresponding input of the
    /// encapsulating effect.
    /// </summary>
    HRESULT ConnectToEffectInput(
        UINT32 toEffectInputIndex,
        ID2D1TransformNode node,
        UINT32 toNodeInputIndex 
        );
    
    /// <summary>
    /// Clears all nodes and connections from the transform graph.
    /// </summary>
    void Clear();
    
    /// <summary>
    /// Uses the specified input as the effect output.
    /// </summary>
    HRESULT SetPassthroughGraph(
        UINT32 effectInputIndex 
        );
} // interface ID2D1TransformGraph


mixin(uuid!(ID2D1Transform, "ef1a287d-342a-4f76-8fdb-da0d6ea9f92b"));
/// <summary>
/// The interface implemented by a transform author.
/// </summary>
interface ID2D1Transform : ID2D1TransformNode
{
	extern(Windows):
    HRESULT MapOutputRectToInputRects(
        const(D2D1_RECT_L)* outputRect,
        D2D1_RECT_L* inputRects,
        UINT32 inputRectsCount 
        ) const;
    
    HRESULT MapInputRectsToOutputRect(
        const(D2D1_RECT_L)* inputRects,
        const(D2D1_RECT_L)* inputOpaqueSubRects,
        UINT32 inputRectCount,
        D2D1_RECT_L* outputRect,
        D2D1_RECT_L* outputOpaqueSubRect 
        );
    
    HRESULT MapInvalidRect(
        UINT32 inputIndex,
        D2D1_RECT_L invalidInputRect,
        D2D1_RECT_L* invalidOutputRect 
        ) const;
} // interface ID2D1Transform


mixin(uuid!(ID2D1DrawTransform, "36bfdcb6-9739-435d-a30d-a653beff6a6f"));
/// <summary>
/// The interface implemented by a transform author to provide a GPU-based effect.
/// </summary>
interface ID2D1DrawTransform : ID2D1Transform
{
	extern(Windows):
    HRESULT SetDrawInfo(ID2D1DrawInfo drawInfo);
} // interface ID2D1DrawTransform


mixin(uuid!(ID2D1ComputeTransform, "0d85573c-01e3-4f7d-bfd9-0d60608bf3c3"));
/// <summary>
/// The interface implemented by a transform author to provide a Compute Shader
/// based effect.
/// </summary>
interface ID2D1ComputeTransform : ID2D1Transform
{
    extern(Windows):
    HRESULT SetComputeInfo(ID2D1ComputeInfo computeInfo);
    
    HRESULT CalculateThreadgroups(
        const(D2D1_RECT_L)* outputRect,
        UINT32* dimensionX,
        UINT32* dimensionY,
        UINT32* dimensionZ 
        );
} // interface ID2D1ComputeTransform


mixin(uuid!(ID2D1AnalysisTransform, "0359dc30-95e6-4568-9055-27720d130e93"));
/// <summary>
/// The interface implemented by a transform author to indicate that it should
/// receive an analysis result callback.
/// </summary>
interface ID2D1AnalysisTransform : IUnknown
{
    extern(Windows):
    HRESULT ProcessAnalysisResults(
        const(BYTE)* analysisData,
        UINT32 analysisDataCount 
        );
} // interface ID2D1AnalysisTransform


mixin(uuid!(ID2D1SourceTransform, "db1800dd-0c34-4cf9-be90-31cc0a5653e1"));
/// <summary>
/// The interface implemented by a transform author to provide a CPU based source
/// effect.
/// </summary>
interface ID2D1SourceTransform : ID2D1Transform
{
    extern(Windows):
    HRESULT SetRenderInfo(ID2D1RenderInfo renderInfo);
    
    HRESULT Draw(
        ID2D1Bitmap1 target,
        const(D2D1_RECT_L)* drawRect,
        D2D1_POINT_2U targetOrigin 
        );
} // interface ID2D1SourceTransform


mixin(uuid!(ID2D1ConcreteTransform, "1a799d8a-69f7-4e4c-9fed-437ccc6684cc"));
/// <summary>
/// Base interface for built-in transforms on which precision and caching may be
/// controlled.
/// </summary>
interface ID2D1ConcreteTransform : ID2D1TransformNode
{
    extern(Windows):
    /// <summary>
    /// Controls the output precision and channel-depth for this transform.
    /// </summary>
    HRESULT SetOutputBuffer(
        D2D1_BUFFER_PRECISION bufferPrecision,
        D2D1_CHANNEL_DEPTH channelDepth 
        );
    
    /// <summary>
    /// Controls whether the output of this transform is cached.
    /// </summary>
    void SetCached(BOOL isCached);
} // interface ID2D1ConcreteTransform


mixin(uuid!(ID2D1BlendTransform, "63ac0b32-ba44-450f-8806-7f4ca1ff2f1b"));
/// <summary>
/// An effect uses this interface to configure a blending operation.
/// </summary>
interface ID2D1BlendTransform : ID2D1ConcreteTransform
{
    extern(Windows):
    void SetDescription(const(D2D1_BLEND_DESCRIPTION)* description);
    
    void GetDescription(D2D1_BLEND_DESCRIPTION* description) const;
} // interface ID2D1BlendTransform


mixin(uuid!(ID2D1BorderTransform, "4998735c-3a19-473c-9781-656847e3a347"));
/// <summary>
/// An effect uses this interface to configure border generation.
/// </summary>
interface ID2D1BorderTransform :ID2D1ConcreteTransform
{
    extern(Windows):
    void SetExtendModeX(D2D1_EXTEND_MODE extendMode);
    
    void SetExtendModeY(D2D1_EXTEND_MODE extendMode);
    
    D2D1_EXTEND_MODE GetExtendModeX() const;
    
    D2D1_EXTEND_MODE GetExtendModeY() const;
} // interface ID2D1BorderTransform


mixin(uuid!(ID2D1OffsetTransform, "3fe6adea-7643-4f53-bd14-a0ce63f24042"));
/// <summary>
/// An effect uses this interface to offset an image without inserting a rendering
/// pass.
/// </summary>
interface ID2D1OffsetTransform : ID2D1TransformNode
{
    extern(Windows):
    void SetOffset(D2D1_POINT_2L offset);
    
    D2D1_POINT_2L GetOffset() const;
} // interface ID2D1OffsetTransform


mixin(uuid!(ID2D1BoundsAdjustmentTransform, "90f732e2-5092-4606-a819-8651970baccd"));
/// <summary>
/// An effect uses this interface to alter the image rectangle of its input.
/// </summary>
interface ID2D1BoundsAdjustmentTransform : ID2D1TransformNode
{
    extern(Windows):
    void SetOutputBounds(const(D2D1_RECT_L)* outputBounds);
    
    void GetOutputBounds(D2D1_RECT_L* outputBounds) const;
} // interface ID2D1BoundsAdjustmentTransform


mixin(uuid!(ID2D1EffectImpl, "a248fd3f-3e6c-4e63-9f03-7f68ecc91db9"));
/// <summary>
/// This is the interface implemented by an effect author, along with the
/// constructor and registration information.
/// </summary>
interface ID2D1EffectImpl : IUnknown
{
    extern(Windows):
    /// <summary>
    /// Initialize the effect with a context and a transform graph. The effect must
    /// populate the transform graph with a topology and can update it later.
    /// </summary>
    HRESULT Initialize(
        ID2D1EffectContext effectContext,
        ID2D1TransformGraph transformGraph 
        );
    
    /// <summary>
    /// Initialize the effect with a context and a transform graph. The effect must
    /// populate the transform graph with a topology and can update it later.
    /// </summary>
    HRESULT PrepareForRender(
        D2D1_CHANGE_TYPE changeType 
        );
    
    /// <summary>
    /// Sets a new transform graph to the effect.  This happens when the number of
    /// inputs to the effect changes, if the effect support a variable number of inputs.
    /// </summary>
    HRESULT SetGraph(
        ID2D1TransformGraph transformGraph 
        );
} // interface ID2D1EffectImpl


mixin(uuid!(ID2D1EffectContext, "3d9f916b-27dc-4ad7-b4f1-64945340f563"));
/// <summary>
/// The internal context handed to effect authors to create transforms from effects
/// and any other operation tied to context which is not useful to the application
/// facing API.
/// </summary>
interface ID2D1EffectContext : IUnknown
{
    
    void GetDpi(
        FLOAT* dpiX,
        FLOAT* dpiY 
        ) const;
    
    /// <summary>
    /// Create a new effect, the effect must either be built in or previously registered
    /// through ID2D1Factory1::RegisterEffect.
    /// </summary>
    HRESULT CreateEffect(
        REFCLSID effectId,
        ID2D1Effect *effect 
        );
    
    HRESULT GetMaximumSupportedFeatureLevel(
        const(D3D_FEATURE_LEVEL)* featureLevels,
        UINT32 featureLevelsCount,
        D3D_FEATURE_LEVEL* maximumSupportedFeatureLevel 
        ) const;
    
    /// <summary>
    /// Create a transform node from the passed in effect.
    /// </summary>
    HRESULT CreateTransformNodeFromEffect(
        ID2D1Effect effect,
        ID2D1TransformNode *transformNode 
        );
    
    HRESULT CreateBlendTransform(
        UINT32 numInputs,
        const(D2D1_BLEND_DESCRIPTION)* blendDescription,
        ID2D1BlendTransform *transform 
        );
    
    HRESULT CreateBorderTransform(
        D2D1_EXTEND_MODE extendModeX,
        D2D1_EXTEND_MODE extendModeY,
        ID2D1BorderTransform *transform 
        );
    
    HRESULT CreateOffsetTransform(
        D2D1_POINT_2L offset,
        ID2D1OffsetTransform *transform 
        );
    
    HRESULT CreateBoundsAdjustmentTransform(
        const(D2D1_RECT_L)* outputRectangle,
        ID2D1BoundsAdjustmentTransform *transform 
        );
    
    HRESULT LoadPixelShader(
        REFGUID shaderId,
        const(BYTE)* shaderBuffer,
        UINT32 shaderBufferCount 
        );
    
    HRESULT LoadVertexShader(
        REFGUID resourceId,
        const(BYTE)* shaderBuffer,
        UINT32 shaderBufferCount 
        );
    
    HRESULT LoadComputeShader(
        REFGUID resourceId,
        const(BYTE)* shaderBuffer,
        UINT32 shaderBufferCount 
        );
    
    BOOL IsShaderLoaded(REFGUID shaderId);
    
    HRESULT CreateResourceTexture(
        const(GUID)* resourceId,
        const(D2D1_RESOURCE_TEXTURE_PROPERTIES)* resourceTextureProperties,
    	const(BYTE)* data,
        const(UINT32)* strides,
        UINT32 dataSize,
        ID2D1ResourceTexture *resourceTexture 
        );
    
    HRESULT FindResourceTexture(
        const(GUID)* resourceId,
        ID2D1ResourceTexture *resourceTexture 
        );
    
    HRESULT CreateVertexBuffer(
        const(D2D1_VERTEX_BUFFER_PROPERTIES)* vertexBufferProperties,
        const(GUID)* resourceId,
        const(D2D1_CUSTOM_VERTEX_BUFFER_PROPERTIES)* customVertexBufferProperties,
        ID2D1VertexBuffer *buffer 
        );
    
    HRESULT FindVertexBuffer(
        const(GUID)* resourceId,
        ID2D1VertexBuffer *buffer 
        );
    
    /// <summary>
    /// Creates a color context from a color space.  If the space is Custom, the context
    /// is initialized from the profile/profileSize arguments.  Otherwise the context is
    /// initialized with the profile bytes associated with the space and
    /// profile/profileSize are ignored.
    /// </summary>
    HRESULT CreateColorContext(
        D2D1_COLOR_SPACE space,
        const(BYTE)* profile,
        UINT32 profileSize,
        ID2D1ColorContext *colorContext 
        );
    
    HRESULT CreateColorContextFromFilename(
        PCWSTR filename,
        ID2D1ColorContext *colorContext 
        );
    
    HRESULT CreateColorContextFromWicColorContext(
        IWICColorContext wicColorContext,
        ID2D1ColorContext *colorContext 
        );
    
    HRESULT CheckFeatureSupport(
        D2D1_FEATURE feature,
        void* featureSupportData,
        UINT32 featureSupportDataSize 
        ) const;
    
    /// <summary>
    /// Indicates whether the buffer precision is supported by D2D.
    /// </summary>
    BOOL IsBufferPrecisionSupported(D2D1_BUFFER_PRECISION bufferPrecision) const;
} // interface ID2D1EffectContext
