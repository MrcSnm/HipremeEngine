module directx.d2d1_1;
//---------------------------------------------------------------------------
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
// This file is automatically generated.  Please do not edit it directly.
//
// File name: D2D1_1.h
//---------------------------------------------------------------------------

version(Windows):

public import directx.com;
public import directx.d2d1;
public import directx.d2d1effects;
public import directx.dxgi;
public import directx.dwrite, directx.wincodec;

import directx.d2d1effectauthor;
import core.sys.windows.objidl;

/// <summary>
/// Function pointer to construct a new effect once registered.
/// </summary>
alias PD2D1_EFFECT_FACTORY = extern(Windows) HRESULT function(IUnknown* effectImpl);
enum D2D1_INVALID_PROPERTY_INDEX = uint.max;
alias D2D1_RECT_L = D2D_RECT_L;
alias D2D1_POINT_2L = D2D_POINT_2L;

/// <summary>
/// This defines the valid property types that can be used in an effect property
/// interface.
/// </summary>
alias D2D1_PROPERTY_TYPE = uint;
enum : D2D1_PROPERTY_TYPE
{
    D2D1_PROPERTY_TYPE_UNKNOWN = 0,
    D2D1_PROPERTY_TYPE_STRING = 1,
    D2D1_PROPERTY_TYPE_BOOL = 2,
    D2D1_PROPERTY_TYPE_UINT32 = 3,
    D2D1_PROPERTY_TYPE_INT32 = 4,
    D2D1_PROPERTY_TYPE_FLOAT = 5,
    D2D1_PROPERTY_TYPE_VECTOR2 = 6,
    D2D1_PROPERTY_TYPE_VECTOR3 = 7,
    D2D1_PROPERTY_TYPE_VECTOR4 = 8,
    D2D1_PROPERTY_TYPE_BLOB = 9,
    D2D1_PROPERTY_TYPE_IUNKNOWN = 10,
    D2D1_PROPERTY_TYPE_ENUM = 11,
    D2D1_PROPERTY_TYPE_ARRAY = 12,
    D2D1_PROPERTY_TYPE_CLSID = 13,
    D2D1_PROPERTY_TYPE_MATRIX_3X2 = 14,
    D2D1_PROPERTY_TYPE_MATRIX_4X3 = 15,
    D2D1_PROPERTY_TYPE_MATRIX_4X4 = 16,
    D2D1_PROPERTY_TYPE_MATRIX_5X4 = 17,
    D2D1_PROPERTY_TYPE_COLOR_CONTEXT = 18,
    D2D1_PROPERTY_TYPE_FORCE_DWORD = 0xffffffff

}


/// <summary>
/// This defines the list of system properties present on the root effect property
/// interface.
/// </summary>
alias D2D1_PROPERTY = uint;
enum : D2D1_PROPERTY
{
    D2D1_PROPERTY_CLSID = 0x80000000,
    D2D1_PROPERTY_DISPLAYNAME = 0x80000001,
    D2D1_PROPERTY_AUTHOR = 0x80000002,
    D2D1_PROPERTY_CATEGORY = 0x80000003,
    D2D1_PROPERTY_DESCRIPTION = 0x80000004,
    D2D1_PROPERTY_INPUTS = 0x80000005,
    D2D1_PROPERTY_CACHED = 0x80000006,
    D2D1_PROPERTY_PRECISION = 0x80000007,
    D2D1_PROPERTY_MIN_INPUTS = 0x80000008,
    D2D1_PROPERTY_MAX_INPUTS = 0x80000009
}


/// <summary>
/// This defines the indices of sub-properties that may be present on any parent
/// property.
/// </summary>
alias D2D1_SUBPROPERTY = uint;
enum : D2D1_SUBPROPERTY
{
    D2D1_SUBPROPERTY_DISPLAYNAME = 0x80000000,
    D2D1_SUBPROPERTY_ISREADONLY = 0x80000001,
    D2D1_SUBPROPERTY_MIN = 0x80000002,
    D2D1_SUBPROPERTY_MAX = 0x80000003,
    D2D1_SUBPROPERTY_DEFAULT = 0x80000004,
    D2D1_SUBPROPERTY_FIELDS = 0x80000005,
    D2D1_SUBPROPERTY_INDEX = 0x80000006
}


/// <summary>
/// Specifies how the bitmap can be used.
/// </summary>
alias D2D1_BITMAP_OPTIONS = uint;
enum : D2D1_BITMAP_OPTIONS
{
    
    /// <summary>
    /// The bitmap is created with default properties.
    /// </summary>
    D2D1_BITMAP_OPTIONS_NONE = 0x00000000,
    
    /// <summary>
    /// The bitmap can be specified as a target in ID2D1DeviceContext::SetTarget
    /// </summary>
    D2D1_BITMAP_OPTIONS_TARGET = 0x00000001,
    
    /// <summary>
    /// The bitmap cannot be used as an input to DrawBitmap, DrawImage, in a bitmap
    /// brush or as an input to an effect.
    /// </summary>
    D2D1_BITMAP_OPTIONS_CANNOT_DRAW = 0x00000002,
    
    /// <summary>
    /// The bitmap can be read from the CPU.
    /// </summary>
    D2D1_BITMAP_OPTIONS_CPU_READ = 0x00000004,
    
    /// <summary>
    /// The bitmap works with the ID2D1GdiInteropRenderTarget::GetDC API.
    /// </summary>
    D2D1_BITMAP_OPTIONS_GDI_COMPATIBLE = 0x00000008
}


/// <summary>
/// Specifies the composite mode that will be applied.
/// </summary>
alias D2D1_COMPOSITE_MODE = uint;
enum : D2D1_COMPOSITE_MODE
{
    D2D1_COMPOSITE_MODE_SOURCE_OVER = 0,
    D2D1_COMPOSITE_MODE_DESTINATION_OVER = 1,
    D2D1_COMPOSITE_MODE_SOURCE_IN = 2,
    D2D1_COMPOSITE_MODE_DESTINATION_IN = 3,
    D2D1_COMPOSITE_MODE_SOURCE_OUT = 4,
    D2D1_COMPOSITE_MODE_DESTINATION_OUT = 5,
    D2D1_COMPOSITE_MODE_SOURCE_ATOP = 6,
    D2D1_COMPOSITE_MODE_DESTINATION_ATOP = 7,
    D2D1_COMPOSITE_MODE_XOR = 8,
    D2D1_COMPOSITE_MODE_PLUS = 9,
    D2D1_COMPOSITE_MODE_SOURCE_COPY = 10,
    D2D1_COMPOSITE_MODE_BOUNDED_SOURCE_COPY = 11,
    D2D1_COMPOSITE_MODE_MASK_INVERT = 12
}


/// <summary>
/// This specifies the precision that should be used in buffers allocated by D2D.
/// </summary>
alias D2D1_BUFFER_PRECISION = uint;
enum : D2D1_BUFFER_PRECISION
{
    D2D1_BUFFER_PRECISION_UNKNOWN = 0,
    D2D1_BUFFER_PRECISION_8BPC_UNORM = 1,
    D2D1_BUFFER_PRECISION_8BPC_UNORM_SRGB = 2,
    D2D1_BUFFER_PRECISION_16BPC_UNORM = 3,
    D2D1_BUFFER_PRECISION_16BPC_FLOAT = 4,
    D2D1_BUFFER_PRECISION_32BPC_FLOAT = 5
}


/// <summary>
/// This describes how the individual mapping operation should be performed.
/// </summary>
alias D2D1_MAP_OPTIONS = uint;
enum : D2D1_MAP_OPTIONS
{
    
    /// <summary>
    /// The mapped pointer has undefined behavior.
    /// </summary>
    D2D1_MAP_OPTIONS_NONE = 0,
    
    /// <summary>
    /// The mapped pointer can be read from.
    /// </summary>
    D2D1_MAP_OPTIONS_READ = 1,
    
    /// <summary>
    /// The mapped pointer can be written to.
    /// </summary>
    D2D1_MAP_OPTIONS_WRITE = 2,
    
    /// <summary>
    /// The previous contents of the bitmap are discarded when it is mapped.
    /// </summary>
    D2D1_MAP_OPTIONS_DISCARD = 4
}


/// <summary>
/// This is used to specify the quality of image scaling with
/// ID2D1DeviceContext::DrawImage and with the 2D Affine Transform Effect.
/// </summary>
alias D2D1_INTERPOLATION_MODE = uint;
enum : D2D1_INTERPOLATION_MODE
{
    D2D1_INTERPOLATION_MODE_NEAREST_NEIGHBOR = D2D1_INTERPOLATION_MODE_DEFINITION_NEAREST_NEIGHBOR,
    D2D1_INTERPOLATION_MODE_LINEAR = D2D1_INTERPOLATION_MODE_DEFINITION_LINEAR,
    D2D1_INTERPOLATION_MODE_CUBIC = D2D1_INTERPOLATION_MODE_DEFINITION_CUBIC,
    D2D1_INTERPOLATION_MODE_MULTI_SAMPLE_LINEAR = D2D1_INTERPOLATION_MODE_DEFINITION_MULTI_SAMPLE_LINEAR,
    D2D1_INTERPOLATION_MODE_ANISOTROPIC = D2D1_INTERPOLATION_MODE_DEFINITION_ANISOTROPIC,
    D2D1_INTERPOLATION_MODE_HIGH_QUALITY_CUBIC = D2D1_INTERPOLATION_MODE_DEFINITION_HIGH_QUALITY_CUBIC
}


/// <summary>
/// This specifies what units should be accepted by the D2D API.
/// </summary>
alias D2D1_UNIT_MODE = uint;
enum : D2D1_UNIT_MODE
{
    D2D1_UNIT_MODE_DIPS = 0,
    D2D1_UNIT_MODE_PIXELS = 1
}


/// <summary>
/// Defines a color space.
/// </summary>
alias D2D1_COLOR_SPACE = uint;
enum : D2D1_COLOR_SPACE
{
    
    /// <summary>
    /// The color space is described by accompanying data, such as a color profile.
    /// </summary>
    D2D1_COLOR_SPACE_CUSTOM = 0,
    
    /// <summary>
    /// The sRGB color space.
    /// </summary>
    D2D1_COLOR_SPACE_SRGB = 1,
    
    /// <summary>
    /// The scRGB color space.
    /// </summary>
    D2D1_COLOR_SPACE_SCRGB = 2
}


/// <summary>
/// This specifies options that apply to the device context for its lifetime.
/// </summary>
alias D2D1_DEVICE_CONTEXT_OPTIONS = uint;
enum : D2D1_DEVICE_CONTEXT_OPTIONS
{
    D2D1_DEVICE_CONTEXT_OPTIONS_NONE = 0,
    
    /// <summary>
    /// Geometry rendering will be performed on many threads in parallel, a single
    /// thread is the default.
    /// </summary>
    D2D1_DEVICE_CONTEXT_OPTIONS_ENABLE_MULTITHREADED_OPTIMIZATIONS = 1
}


/// <summary>
/// Defines how the world transform, dots per inch (dpi), and stroke width affect
/// the shape of the pen used to stroke a primitive.
/// </summary>
alias D2D1_STROKE_TRANSFORM_TYPE = uint;
enum : D2D1_STROKE_TRANSFORM_TYPE
{
    
    /// <summary>
    /// The stroke respects the world transform, the DPI, and the stroke width.
    /// </summary>
    D2D1_STROKE_TRANSFORM_TYPE_NORMAL = 0,
    
    /// <summary>
    /// The stroke does not respect the world transform, but it does respect the DPI and
    /// the stroke width.
    /// </summary>
    D2D1_STROKE_TRANSFORM_TYPE_FIXED = 1,
    
    /// <summary>
    /// The stroke is forced to one pixel wide.
    /// </summary>
    D2D1_STROKE_TRANSFORM_TYPE_HAIRLINE = 2
}


/// <summary>
/// A blend mode that applies to all primitives drawn on the context.
/// </summary>
alias D2D1_PRIMITIVE_BLEND = uint;
enum : D2D1_PRIMITIVE_BLEND
{
    D2D1_PRIMITIVE_BLEND_SOURCE_OVER = 0,
    D2D1_PRIMITIVE_BLEND_COPY = 1,
    D2D1_PRIMITIVE_BLEND_MIN = 2,
    D2D1_PRIMITIVE_BLEND_ADD = 3,
    D2D1_PRIMITIVE_BLEND_MAX = 4
}


/// <summary>
/// This specifies the threading mode used while simultaneously creating the device,
/// factory, and device context.
/// </summary>
alias D2D1_THREADING_MODE = uint;
enum : D2D1_THREADING_MODE
{
    
    /// <summary>
    /// Resources may only be invoked serially.  Reference counts on resources are
    /// interlocked, however, resource and render target state is not protected from
    /// multi-threaded access
    /// </summary>
    D2D1_THREADING_MODE_SINGLE_THREADED = D2D1_FACTORY_TYPE_SINGLE_THREADED,
    
    /// <summary>
    /// Resources may be invoked from multiple threads. Resources use interlocked
    /// reference counting and their state is protected.
    /// </summary>
    D2D1_THREADING_MODE_MULTI_THREADED = D2D1_FACTORY_TYPE_MULTI_THREADED
}


/// <summary>
/// This specifies how colors are interpolated.
/// </summary>
alias D2D1_COLOR_INTERPOLATION_MODE = uint;
enum : D2D1_COLOR_INTERPOLATION_MODE
{
    
    /// <summary>
    /// Colors will be interpolated in straight alpha space.
    /// </summary>
    D2D1_COLOR_INTERPOLATION_MODE_STRAIGHT = 0,
    
    /// <summary>
    /// Colors will be interpolated in premultiplied alpha space.
    /// </summary>
    D2D1_COLOR_INTERPOLATION_MODE_PREMULTIPLIED = 1
}

alias D2D1_VECTOR_2F = D2D_VECTOR_2F;
alias D2D1_VECTOR_3F = D2D_VECTOR_3F;
alias D2D1_VECTOR_4F = D2D_VECTOR_4F;

/// <summary>
/// Extended bitmap properties.
/// </summary>
struct D2D1_BITMAP_PROPERTIES1
{
    D2D1_PIXEL_FORMAT pixelFormat;
    FLOAT dpiX;
    FLOAT dpiY;
    
    /// <summary>
    /// Specifies how the bitmap can be used.
    /// </summary>
    D2D1_BITMAP_OPTIONS bitmapOptions;
    ID2D1ColorContext colorContext;
}


/// <summary>
/// Describes mapped memory from the ID2D1Bitmap1::Map API.
/// </summary>
struct D2D1_MAPPED_RECT
{
    UINT32 pitch;
    BYTE* bits;
}


/// <summary>
/// This controls advanced settings of the Direct2D imaging pipeline.
/// </summary>
struct D2D1_RENDERING_CONTROLS
{
    /// <summary>
    /// The default buffer precision, used if the precision isn't otherwise specified.
    /// </summary>
    D2D1_BUFFER_PRECISION bufferPrecision;
    
    /// <summary>
    /// The size of allocated tiles used to render imaging effects.
    /// </summary>
    D2D1_SIZE_U tileSize;
}


/// <summary>
/// This identifies a certain input connection of a certain effect.
/// </summary>
struct D2D1_EFFECT_INPUT_DESCRIPTION
{
    /// <summary>
    /// The effect whose input connection is being specified.
    /// </summary>
    ID2D1Effect effect;
    
    /// <summary>
    /// The index of the input connection into the specified effect.
    /// </summary>
    UINT32 inputIndex;
    
    /// <summary>
    /// The rectangle which would be available on the specified input connection during
    /// render operations.
    /// </summary>
    D2D1_RECT_F inputRectangle;
}

alias D2D1_MATRIX_4X3_F = D2D_MATRIX_4X3_F;
alias D2D1_MATRIX_4X4_F = D2D_MATRIX_4X4_F;
alias D2D1_MATRIX_5X4_F = D2D_MATRIX_5X4_F;

/// <summary>
/// Describes a point along a path.
/// </summary>
struct D2D1_POINT_DESCRIPTION
{
    D2D1_POINT_2F point;
    D2D1_POINT_2F unitTangentVector;
    UINT32 endSegment;
    UINT32 endFigure;
    FLOAT lengthToEndSegment;
}


/// <summary>
/// Creation properties for an image brush.
/// </summary>
struct D2D1_IMAGE_BRUSH_PROPERTIES
{
    D2D1_RECT_F sourceRectangle;
    D2D1_EXTEND_MODE extendModeX;
    D2D1_EXTEND_MODE extendModeY;
    D2D1_INTERPOLATION_MODE interpolationMode;
}


/// <summary>
/// Describes the extend modes and the interpolation mode of an ID2D1BitmapBrush.
/// </summary>
struct D2D1_BITMAP_BRUSH_PROPERTIES1
{
    D2D1_EXTEND_MODE extendModeX;
    D2D1_EXTEND_MODE extendModeY;
    D2D1_INTERPOLATION_MODE interpolationMode;
}


/// <summary>
/// This defines how geometries should be drawn and widened.
/// </summary>
struct D2D1_STROKE_STYLE_PROPERTIES1
{
    D2D1_CAP_STYLE startCap;
    D2D1_CAP_STYLE endCap;
    D2D1_CAP_STYLE dashCap;
    D2D1_LINE_JOIN lineJoin;
    FLOAT miterLimit;
    D2D1_DASH_STYLE dashStyle;
    FLOAT dashOffset;
    
    /// <summary>
    /// How the nib of the stroke is influenced by the context properties.
    /// </summary>
    D2D1_STROKE_TRANSFORM_TYPE transformType;
}


/// <summary>
/// Specifies how the layer contents should be prepared.
/// </summary>
alias D2D1_LAYER_OPTIONS1 = uint;
enum : D2D1_LAYER_OPTIONS1
{
    D2D1_LAYER_OPTIONS1_NONE = 0,
    D2D1_LAYER_OPTIONS1_INITIALIZE_FROM_BACKGROUND = 1,
    D2D1_LAYER_OPTIONS1_IGNORE_ALPHA = 2
}


/// <summary>
/// All parameters related to pushing a layer.
/// </summary>
struct D2D1_LAYER_PARAMETERS1
{
    D2D1_RECT_F contentBounds;
    ID2D1Geometry geometricMask;
    D2D1_ANTIALIAS_MODE maskAntialiasMode;
    D2D1_MATRIX_3X2_F maskTransform;
    FLOAT opacity;
    ID2D1Brush opacityBrush;
    D2D1_LAYER_OPTIONS1 layerOptions;
}


/// <summary>
/// Defines when font resources should be subset during printing.
/// </summary>
alias D2D1_PRINT_FONT_SUBSET_MODE = uint;
enum : D2D1_PRINT_FONT_SUBSET_MODE
{
    
    /// <summary>
    /// Subset for used glyphs, send and discard font resource after every five pages
    /// </summary>
    D2D1_PRINT_FONT_SUBSET_MODE_DEFAULT = 0,
    
    /// <summary>
    /// Subset for used glyphs, send and discard font resource after each page
    /// </summary>
    D2D1_PRINT_FONT_SUBSET_MODE_EACHPAGE = 1,
    
    /// <summary>
    /// Do not subset, reuse font for all pages, send it after first page
    /// </summary>
    D2D1_PRINT_FONT_SUBSET_MODE_NONE = 2
}


/// <summary>
/// This describes the drawing state.
/// </summary>
struct D2D1_DRAWING_STATE_DESCRIPTION1
{
    D2D1_ANTIALIAS_MODE antialiasMode;
    D2D1_TEXT_ANTIALIAS_MODE textAntialiasMode;
    D2D1_TAG tag1;
    D2D1_TAG tag2;
    D2D1_MATRIX_3X2_F transform;
    D2D1_PRIMITIVE_BLEND primitiveBlend;
    D2D1_UNIT_MODE unitMode;
}


/// <summary>
/// The creation properties for a ID2D1PrintControl object.
/// </summary>
struct D2D1_PRINT_CONTROL_PROPERTIES
{
    D2D1_PRINT_FONT_SUBSET_MODE fontSubset;
    
    /// <summary>
    /// DPI for rasterization of all unsupported D2D commands or options, defaults to
    /// 150.0
    /// </summary>
    FLOAT rasterDPI;
    
    /// <summary>
    /// Color space for vector graphics in XPS package
    /// </summary>
    D2D1_COLOR_SPACE colorSpace;
}


/// <summary>
/// This specifies the options while simultaneously creating the device, factory,
/// and device context.
/// </summary>
struct D2D1_CREATION_PROPERTIES
{
    
    /// <summary>
    /// Describes locking behavior of D2D resources
    /// </summary>
    D2D1_THREADING_MODE threadingMode;
    D2D1_DEBUG_LEVEL debugLevel;
    D2D1_DEVICE_CONTEXT_OPTIONS options;
}

mixin(uuid!(ID2D1GdiMetafileSink, "82237326-8111-4f7c-bcf4-b5c1175564fe"));
/// <summary>
/// User-implementable interface for introspecting on a metafile.
/// </summary>
interface ID2D1GdiMetafileSink : IUnknown
{
	extern(Windows):
    /// <summary>
    /// Callback for examining a metafile record.
    /// </summary>
    HRESULT ProcessRecord(
        DWORD recordType,
        const(void)* recordData,
        DWORD recordDataSize 
        );
} // interface ID2D1GdiMetafileSink


mixin(uuid!(ID2D1GdiMetafile, "2f543dc3-cfc1-4211-864f-cfd91c6f3395"));
/// <summary>
/// Interface encapsulating a GDI/GDI+ metafile.
/// </summary>
interface ID2D1GdiMetafile : ID2D1Resource
{
	extern(Windows):
    /// <summary>
    /// Play the metafile into a caller-supplied sink interface.
    /// </summary>
    HRESULT Stream(ID2D1GdiMetafileSink sink);
    
    /// <summary>
    /// Gets the bounds of the metafile.
    /// </summary>
    HRESULT GetBounds(D2D1_RECT_F* bounds);
} // interface ID2D1GdiMetafile


mixin(uuid!(ID2D1CommandSink, "54d7898a-a061-40a7-bec7-e465bcba2c4f"));
/// <summary>
/// Caller-supplied implementation of an interface to receive the recorded command
/// list.
/// </summary>
interface ID2D1CommandSink : IUnknown
{
	extern(Windows):
    HRESULT BeginDraw();
    HRESULT EndDraw();
    HRESULT SetAntialiasMode(D2D1_ANTIALIAS_MODE antialiasMode);
    HRESULT SetTags(D2D1_TAG tag1, D2D1_TAG tag2);
    HRESULT SetTextAntialiasMode(D2D1_TEXT_ANTIALIAS_MODE textAntialiasMode);
    HRESULT SetTextRenderingParams(IDWriteRenderingParams textRenderingParams);
    HRESULT SetTransform(const(D2D1_MATRIX_3X2_F)* transform);
    HRESULT SetPrimitiveBlend(D2D1_PRIMITIVE_BLEND primitiveBlend);
    HRESULT SetUnitMode(D2D1_UNIT_MODE unitMode);
    HRESULT Clear(const(D2D1_COLOR_F)* color);
    HRESULT DrawGlyphRun(
        D2D1_POINT_2F baselineOrigin,
        const(DWRITE_GLYPH_RUN)* glyphRun,
        const(DWRITE_GLYPH_RUN_DESCRIPTION)* glyphRunDescription,
        ID2D1Brush foregroundBrush,
        DWRITE_MEASURING_MODE measuringMode 
        );
    HRESULT DrawLine(
        D2D1_POINT_2F point0,
        D2D1_POINT_2F point1,
        ID2D1Brush brush,
        FLOAT strokeWidth,
        ID2D1StrokeStyle strokeStyle 
        );
    HRESULT DrawGeometry(
        ID2D1Geometry geometry,
        ID2D1Brush brush,
        FLOAT strokeWidth,
        ID2D1StrokeStyle strokeStyle 
        );
    HRESULT DrawRectangle(
        const(D2D1_RECT_F)* rect,
        ID2D1Brush brush,
        FLOAT strokeWidth,
        ID2D1StrokeStyle strokeStyle 
        );
    HRESULT DrawBitmap(
        ID2D1Bitmap bitmap,
        const(D2D1_RECT_F)* destinationRectangle,
        FLOAT opacity,
        D2D1_INTERPOLATION_MODE interpolationMode,
        const(D2D1_RECT_F)* sourceRectangle,
        const(D2D1_MATRIX_4X4_F)* perspectiveTransform 
        );
    HRESULT DrawImage(
        ID2D1Image image,
        const(D2D1_POINT_2F)* targetOffset,
        const(D2D1_RECT_F)* imageRectangle,
        D2D1_INTERPOLATION_MODE interpolationMode,
        D2D1_COMPOSITE_MODE compositeMode 
        );
    HRESULT DrawGdiMetafile(
        ID2D1GdiMetafile gdiMetafile,
        const(D2D1_POINT_2F)* targetOffset 
        );
    HRESULT FillMesh(
        ID2D1Mesh mesh,
        ID2D1Brush brush 
        );
    HRESULT FillOpacityMask(
        ID2D1Bitmap opacityMask,
        ID2D1Brush brush,
        const(D2D1_RECT_F)* destinationRectangle,
        const(D2D1_RECT_F)* sourceRectangle 
        );
    HRESULT FillGeometry(
        ID2D1Geometry geometry,
        ID2D1Brush brush,
        ID2D1Brush opacityBrush 
        );
    HRESULT FillRectangle(
        const(D2D1_RECT_F)* rect,
        ID2D1Brush brush 
        );
    HRESULT PushAxisAlignedClip(
        const(D2D1_RECT_F)* clipRect,
        D2D1_ANTIALIAS_MODE antialiasMode 
        );
    HRESULT PushLayer(
        const(D2D1_LAYER_PARAMETERS1)* layerParameters1,
        ID2D1Layer layer 
        );
    HRESULT PopAxisAlignedClip();
    HRESULT PopLayer();
} // interface ID2D1CommandSink


mixin(uuid!(ID2D1CommandList, "b4f34a19-2383-4d76-94f6-ec343657c3dc"));
/// <summary>
/// The commandList interface.
/// </summary>
interface ID2D1CommandList : ID2D1Image
{
	extern(Windows):
    /// <summary>
    /// Play the command list into a caller-supplied sink interface.
    /// </summary>
    HRESULT Stream(ID2D1CommandSink sink);
    
    /// <summary>
    /// Marks the command list as ready for use.
    /// </summary>
    HRESULT Close();
} // interface ID2D1CommandList

mixin(uuid!(ID2D1PrintControl, "2c1d867d-c290-41c8-ae7e-34a98702e9a5"));
/// <summary>
/// Converts Direct2D primitives stored in an ID2D1CommandList into a fixed page
/// representation. The print sub-system then consumes the primitives.
/// </summary>
interface ID2D1PrintControl : IUnknown
{
	extern(Windows):
    HRESULT AddPage(
        ID2D1CommandList commandList,
        D2D_SIZE_F pageSize,
        IStream pagePrintTicketStream,
        D2D1_TAG* tag1 = null,
        D2D1_TAG* tag2 = null 
        );
    
    HRESULT Close();
} // interface ID2D1PrintControl


mixin(uuid!(ID2D1ImageBrush, "fe9e984d-3f95-407c-b5db-cb94d4e8f87c"));
/// <summary>
/// Provides a brush that can take any effect, command list or bitmap and use it to
/// fill a 2D shape.
/// </summary>
interface ID2D1ImageBrush : ID2D1Brush
{
	extern(Windows):
    void SetImage(ID2D1Image image);
    void SetExtendModeX(D2D1_EXTEND_MODE extendModeX);
    void SetExtendModeY(D2D1_EXTEND_MODE extendModeY);
    void SetInterpolationMode(D2D1_INTERPOLATION_MODE interpolationMode);
    void SetSourceRectangle(const(D2D1_RECT_F)* sourceRectangle);
    void GetImage(ID2D1Image **image) const;
    D2D1_EXTEND_MODE GetExtendModeX() const;
    D2D1_EXTEND_MODE GetExtendModeY() const;
    D2D1_INTERPOLATION_MODE GetInterpolationMode() const;
    void GetSourceRectangle(D2D1_RECT_F* sourceRectangle) const;
} // interface ID2D1ImageBrush


mixin(uuid!(ID2D1BitmapBrush1, "41343a53-e41a-49a2-91cd-21793bbb62e5"));
/// <summary>
/// A bitmap brush allows a bitmap to be used to fill a geometry.  Interpolation
/// mode is specified with D2D1_INTERPOLATION_MODE
/// </summary>
interface ID2D1BitmapBrush1 : ID2D1BitmapBrush
{
	extern(Windows):
    /// <summary>
    /// Sets the interpolation mode used when this brush is used.
    /// </summary>
    void SetInterpolationMode1(D2D1_INTERPOLATION_MODE interpolationMode);
    
    D2D1_INTERPOLATION_MODE GetInterpolationMode1() const;
} // interface ID2D1BitmapBrush1


mixin(uuid!(ID2D1StrokeStyle1, "10a72a66-e91c-43f4-993f-ddf4b82b0b4a"));
/// <summary>
/// Extends a stroke style to allow nominal width strokes.
/// </summary>
interface ID2D1StrokeStyle1 : ID2D1StrokeStyle
{
	extern(Windows):
    D2D1_STROKE_TRANSFORM_TYPE GetStrokeTransformType() const;
} // interface ID2D1StrokeStyle1


mixin(uuid!(ID2D1PathGeometry1, "62baa2d2-ab54-41b7-b872-787e0106a421"));
/// <summary>
/// The ID2D1PathGeometry1 interface adds functionality to ID2D1PathGeometry. In
/// particular, it provides the path geometry-specific
/// ComputePointAndSegmentAtLength method.
/// </summary>
interface ID2D1PathGeometry1 : ID2D1PathGeometry
{
	extern(Windows):
    HRESULT ComputePointAndSegmentAtLength(
        FLOAT length,
        UINT32 startSegment,
        const(D2D1_MATRIX_3X2_F)* worldTransform,
        FLOAT flatteningTolerance,
        D2D1_POINT_DESCRIPTION* pointDescription 
        ) const;
    
    final
    HRESULT
    ComputePointAndSegmentAtLength(
        FLOAT length,
        UINT32 startSegment,
        const D2D1_MATRIX_3X2_F worldTransform,
        FLOAT flatteningTolerance,
        D2D1_POINT_DESCRIPTION pointDescription 
        ) const  
    {
        return ComputePointAndSegmentAtLength(length, startSegment, &worldTransform, flatteningTolerance, &pointDescription);
    }
    
    final
    HRESULT
    ComputePointAndSegmentAtLength(
        FLOAT length,
        UINT32 startSegment,
        const(D2D1_MATRIX_3X2_F)* worldTransform,
        D2D1_POINT_DESCRIPTION* pointDescription 
        ) const  
    {
        return ComputePointAndSegmentAtLength(length, startSegment, worldTransform, D2D1_DEFAULT_FLATTENING_TOLERANCE, pointDescription);
    }
    
    final
    HRESULT
    ComputePointAndSegmentAtLength(
        FLOAT length,
        UINT32 startSegment,
        const(D2D1_MATRIX_3X2_F) worldTransform,
        D2D1_POINT_DESCRIPTION* pointDescription 
        ) const  
    {
        return ComputePointAndSegmentAtLength(length, startSegment, &worldTransform, D2D1_DEFAULT_FLATTENING_TOLERANCE, pointDescription);
    }
} // interface ID2D1PathGeometry1


mixin(uuid!(ID2D1Properties, "483473d7-cd46-4f9d-9d3a-3112aa80159d"));
/// <summary>
/// Represents a set of run-time bindable and discoverable properties that allow a
/// data-driven application to modify the state of a Direct2D effect.
/// </summary>
interface ID2D1Properties : IUnknown
{
	extern(Windows):
    /// <summary>
    /// Returns the total number of custom properties in this interface.
    /// </summary>
    UINT32 GetPropertyCount() const;
    
    /// <summary>
    /// Retrieves the property name from the given property index.
    /// </summary>
    HRESULT GetPropertyName(
        UINT32 index,
        PWSTR name,
        UINT32 nameCount 
        ) const;
    
    /// <summary>
    /// Returns the length of the property name from the given index.
    /// </summary>
    UINT32 GetPropertyNameLength(UINT32 index) const;
    
    /// <summary>
    /// Retrieves the type of the given property.
    /// </summary>
    D2D1_PROPERTY_TYPE GetType(UINT32 index) const;
    
    /// <summary>
    /// Retrieves the property index for the given property name.
    /// </summary>
    UINT32 GetPropertyIndex(PCWSTR name) const;
    
    /// <summary>
    /// Sets the value of the given property using its name.
    /// </summary>
    HRESULT SetValueByName(
        PCWSTR name,
        D2D1_PROPERTY_TYPE type,
        const(BYTE)* data,
        UINT32 dataSize 
        );
    
    /// <summary>
    /// Sets the given value using the property index.
    /// </summary>
    HRESULT SetValue(
        UINT32 index,
        D2D1_PROPERTY_TYPE type,
        const(BYTE)* data,
        UINT32 dataSize 
        );
    
    /// <summary>
    /// Retrieves the given property or sub-property by name. '.' is the delimiter for
    /// sub-properties.
    /// </summary>
    HRESULT GetValueByName(
        PCWSTR name,
        D2D1_PROPERTY_TYPE type,
        BYTE* data,
        UINT32 dataSize 
        ) const;
    
    /// <summary>
    /// Retrieves the given value by index.
    /// </summary>
    HRESULT GetValue(
        UINT32 index,
        D2D1_PROPERTY_TYPE type,
        BYTE* data,
        UINT32 dataSize 
        ) const;
    
    /// <summary>
    /// Returns the value size for the given property index.
    /// </summary>
    UINT32 GetValueSize(UINT32 index) const;
    
    /// <summary>
    /// Retrieves the sub-properties of the given property by index.
    /// </summary>
    HRESULT GetSubProperties(
        UINT32 index,
        ID2D1Properties *subProperties 
        ) const;
    
    final
    HRESULT
    SetValueByName(
        PCWSTR name,
        const(BYTE)* data,
        UINT32 dataSize 
        )  
    {
        return SetValueByName(name, D2D1_PROPERTY_TYPE_UNKNOWN, data, dataSize);
    }
    
    final
    HRESULT
    SetValue(
        UINT32 index,
        const(BYTE)* data,
        UINT32 dataSize 
        )  
    {
        return SetValue(index, D2D1_PROPERTY_TYPE_UNKNOWN, data, dataSize);
    }
    
    final
    HRESULT
    GetValueByName(
        PCWSTR name,
        BYTE* data,
        UINT32 dataSize 
        ) const  
    {
        return GetValueByName(name, D2D1_PROPERTY_TYPE_UNKNOWN, data, dataSize);
    }
    
    final
    HRESULT
    GetValue(
        UINT32 index,
        BYTE* data,
        UINT32 dataSize 
        ) const  
    {
        return GetValue(index, D2D1_PROPERTY_TYPE_UNKNOWN, data, dataSize);
    }
    
    //
    // Templatized helper functions:
    //
    final
    HRESULT GetValueByName(T)(
        PCWSTR propertyName,
        T *value
        ) const
    {
        return GetValueByName(propertyName, cast(BYTE*)value, T.sizeof);
    }
    
    final T GetValueByName(T)(PCWSTR propertyName) const
    {
        T value;
        HRESULT ignoreHr = GetValueByName(propertyName, cast(BYTE*)&value, T.sizeof);
        UNREFERENCED_PARAMETER(ignoreHr);
    
        return value;
    }
    
    
    final HRESULT SetValueByName(T)(
        PCWSTR propertyName,
        const T value
        )
    {
        return SetValueByName(propertyName, cast(const(BYTE)*)&value, T.sizeof);
    }
    
    final HRESULT GetValue(U)(
        U index,
        BYTE* data,
        UINT32 dataSize
        ) const
    {
        return GetValue(cast(UINT32)index, data, dataSize);
    }
    
    final HRESULT GetValue(T, U)(U index, T* value) const
    {
        return GetValue(cast(UINT32)index, cast(BYTE*)value, T.sizeof);
    }
    
    final T GetValue(T, U)(U index) const
    {
        T value;
        HRESULT ignoreHr = GetValue(cast(UINT32)index, cast(BYTE*)&value, T.sizeof);
    
        // Unreferenced variable:
        ignoreHr;
    
        return value;
    }
    
    final HRESULT SetValue(U)(U index, const(BYTE)* data, UINT32 dataSize)
    {
        return SetValue(cast(UINT32)index, data, dataSize);
    }
    
    final HRESULT SetValue(T, U)(U index, const T value)
    {
        return SetValue(cast(UINT32)index, cast(const(BYTE)*)&value, T.sizeof);
    }
    
    final HRESULT GetPropertyName(U)(U index, PWSTR name, UINT32 nameCount) const
    {
        return GetPropertyName(cast(UINT32)index, name, nameCount);
    }
    
    final UINT32 GetPropertyNameLength(U)(U index) const
    {
        return GetPropertyNameLength(cast(UINT32)index);
    }
    
    final D2D1_PROPERTY_TYPE GetType(U)(U index) const
    {
        return GetType(cast(UINT32)index);
    }
    
    
    final UINT32 GetValueSize(U)(U index) const
    {
        return GetValueSize(cast(UINT32)index);
    }
    
    final HRESULT GetSubProperties(U)(U index, out ID2D1Properties subProperties) const
    {
        return GetSubProperties(cast(UINT32)index, &subProperties);
    }
} // interface ID2D1Properties


mixin(uuid!(ID2D1Effect, "28211a43-7d89-476f-8181-2d6159b220ad"));
/// <summary>
/// The effect interface. Properties control how the effect is rendered. The effect
/// is Drawn with the DrawImage call.
/// </summary>
interface ID2D1Effect : ID2D1Properties
{
	extern(Windows):
    /// <summary>
    /// Sets the input to the given effect. The input can be a concrete bitmap or the
    /// output of another effect.
    /// </summary>
    void SetInput(
        UINT32 index,
        ID2D1Image input,
        BOOL invalidate = TRUE 
        );
    
    /// <summary>
    /// If the effect supports a variable number of inputs, this sets the number of
    /// input that are currently active on the effect.
    /// </summary>
    HRESULT SetInputCount(UINT32 inputCount);
    
    /// <summary>
    /// Returns the input image to the effect. The input could be another effect or a
    /// bitmap.
    /// </summary>
    void GetInput(UINT32 index, ID2D1Image **input) const;
    
    /// <summary>
    /// This returns the number of input that are bound into this effect.
    /// </summary>
    UINT32 GetInputCount() const;
    
    /// <summary>
    /// Returns the output image of the given effect. This can be set as the input to
    /// another effect or can be drawn with DrawImage.
    /// </summary>
    void GetOutput(ID2D1Image *outputImage) const;
    
    final
    void
    SetInputEffect(UINT32 index, ID2D1Effect inputEffect, BOOL invalidate = TRUE)  
    {
        
        ID2D1Image output = null;
        if (inputEffect !is null) inputEffect.GetOutput(&output);
        scope(exit) if(output !is null) output.Release();
        SetInput(index, output, invalidate);
    }
} // interface ID2D1Effect


mixin(uuid!(ID2D1Bitmap, "28211a43-7d89-476f-8181-2d6159b220ad"));
/// <summary>
/// Represents a bitmap that can be used as a surface for an ID2D1DeviceContext or
/// mapped into system memory, and can contain additional color context information.
/// </summary>
interface ID2D1Bitmap1 : ID2D1Bitmap
{
	extern(Windows):
    /// <summary>
    /// Retrieves the color context information associated with the bitmap.
    /// </summary>
    void GetColorContext(ID2D1ColorContext *colorContext) const;
    
    /// <summary>
    /// Retrieves the bitmap options used when creating the API.
    /// </summary>
    D2D1_BITMAP_OPTIONS GetOptions() const;
    
    /// <summary>
    /// Retrieves the DXGI surface from the corresponding bitmap, if the bitmap was
    /// created from a device derived from a D3D device.
    /// </summary>
    HRESULT GetSurface(IDXGISurface *dxgiSurface) const;
    
    /// <summary>
    /// Maps the given bitmap into memory. The bitmap must have been created with the
    /// D2D1_BITMAP_OPTIONS_CPU_READ flag.
    /// </summary>
    HRESULT Map(D2D1_MAP_OPTIONS options, D2D1_MAPPED_RECT *mappedRect);
    
    /// <summary>
    /// Unmaps the given bitmap from memory.
    /// </summary>
    HRESULT Unmap();
} // interface ID2D1Bitmap1


mixin(uuid!(ID2D1ColorContext, "1c4820bb-5771-4518-a581-2fe4dd0ec657"));
/// <summary>
/// Represents a color context that can be used with an ID2D1Bitmap1 object.
/// </summary>
interface ID2D1ColorContext : ID2D1Resource
{
	extern(Windows):
    /// <summary>
    /// Retrieves the color space of the color context.
    /// </summary>
    D2D1_COLOR_SPACE GetColorSpace() const;
    
    /// <summary>
    /// Retrieves the size of the color profile, in bytes.
    /// </summary>
    UINT32 GetProfileSize() const;
    
    /// <summary>
    /// Retrieves the color profile bytes.
    /// </summary>
    HRESULT GetProfile(BYTE* profile, UINT32 profileSize) const;
} // interface ID2D1ColorContext


mixin(uuid!(ID2D1GradientStopCollection1, "ae1572f4-5dd0-4777-998b-9279472ae63b"));
/// <summary>
/// Represents an collection of gradient stops that can then be the source resource
/// for either a linear or radial gradient brush.
/// </summary>
interface ID2D1GradientStopCollection1 : ID2D1GradientStopCollection
{
	extern(Windows):
    /// <summary>
    /// Copies the gradient stops from the collection into the caller's memory. If this
    /// object was created using ID2D1DeviceContext::CreateGradientStopCollection, this
    /// method returns the same values as were specified in the creation method. If this
    /// object was created using ID2D1RenderTarget::CreateGradientStopCollection, the
    /// stops returned here will first be transformed into the gamma space specified by
    /// the colorInterpolationGamma parameter.
    /// </summary>
    void GetGradientStops1(D2D1_GRADIENT_STOP* gradientStops, UINT32 gradientStopsCount) const;
    
    /// <summary>
    /// Returns the color space in which interpolation occurs. If this object was
    /// created using ID2D1RenderTarget::CreateGradientStopCollection, this method
    /// returns the color space related to the color interpolation gamma.
    /// </summary>
    D2D1_COLOR_SPACE GetPreInterpolationSpace() const;
    
    /// <summary>
    /// Returns the color space colors will be converted to after interpolation occurs.
    /// If this object was created using
    /// ID2D1RenderTarget::CreateGradientStopCollection, this method returns
    /// D2D1_COLOR_SPACE_SRGB.
    /// </summary>
    D2D1_COLOR_SPACE GetPostInterpolationSpace() const;
    
    /// <summary>
    /// Returns the buffer precision of this gradient. If this object was created using
    /// ID2D1RenderTarget::CreateGradientStopCollection, this method returns
    /// D2D1_BUFFER_PRECISION_8BPC_UNORM.
    /// </summary>
    D2D1_BUFFER_PRECISION GetBufferPrecision() const;
    
    /// <summary>
    /// Returns the interpolation mode used to interpolate colors in the gradient.
    /// </summary>
    D2D1_COLOR_INTERPOLATION_MODE GetColorInterpolationMode() const;
} // interface ID2D1GradientStopCollection1


mixin(uuid!(ID2D1DrawingStateBlock1, "689f1f85-c72e-4e33-8f19-85754efd5ace"));
/// <summary>
/// Represents drawing state.
/// </summary>
interface ID2D1DrawingStateBlock1 : ID2D1DrawingStateBlock
{
	extern(Windows):
    /// <summary>
    /// Retrieves the state currently contained within this state block resource.
    /// </summary>
    void GetDescription(D2D1_DRAWING_STATE_DESCRIPTION1 *stateDescription) const;

    /* using ID2D1DrawingStateBlock::GetDescription; */
    void GetDescription(D2D1_DRAWING_STATE_DESCRIPTION *stateDescription) const;
    
    /// <summary>
    /// Sets the state description of this state block resource.
    /// </summary>
    void SetDescription(const(D2D1_DRAWING_STATE_DESCRIPTION1)* stateDescription);
    
    /* using ID2D1DrawingStateBlock::SetDescription; */
    void SetDescription(const(D2D1_DRAWING_STATE_DESCRIPTION)* stateDescription);
} // interface ID2D1DrawingStateBlock1


mixin(uuid!(ID2D1DeviceContext, "e8f7fe7a-191c-466d-ad95-975678bda998"));
/// <summary>
/// The device context represents a set of state and a command buffer that is used
/// to render to a target bitmap.
/// </summary>
interface ID2D1DeviceContext : ID2D1RenderTarget
{
	extern(Windows):
    /// <summary>
    /// Creates a bitmap with extended bitmap properties, potentially from a block of
    /// memory.
    /// </summary>
    HRESULT CreateBitmap(
        D2D1_SIZE_U size,
        const(void)* sourceData,
        UINT32 pitch,
        const(D2D1_BITMAP_PROPERTIES1)* bitmapProperties,
        ID2D1Bitmap1 *bitmap 
        );
    
    /* using ID2D1RenderTarget::CreateBitmap; */
    HRESULT CreateBitmap(
        D2D1_SIZE_U size,
        const(void*) srcData,
        UINT32 pitch,
        const(D2D1_BITMAP_PROPERTIES)* bitmapProperties,
        /*out*/ID2D1Bitmap* bitmap 
        );
    
    /// <summary>
    /// Create a D2D bitmap by copying a WIC bitmap.
    /// </summary>
    HRESULT CreateBitmapFromWicBitmap(
        IWICBitmapSource wicBitmapSource,
        const(D2D1_BITMAP_PROPERTIES1)* bitmapProperties,
        ID2D1Bitmap1 *bitmap 
        );
    
    /* using ID2D1RenderTarget::CreateBitmapFromWicBitmap; */
    HRESULT CreateBitmapFromWicBitmap(
        IWICBitmapSource wicBitmapSource,
        const(D2D1_BITMAP_PROPERTIES)* bitmapProperties,
        /*out*/ ID2D1Bitmap *bitmap 
        );
    
    /// <summary>
    /// Creates a color context from a color space.  If the space is Custom, the context
    /// is initialized from the profile/profileSize arguments.  Otherwise the context is
    /// initialized with the profile bytes associated with the space and
    /// profile/profileSize are ignored.
    /// </summary>
    HRESULT CreateColorContext(
        D2D1_COLOR_SPACE space,
        const(BYTE)* profile,
        UINT32 profileSize,
        ID2D1ColorContext *colorContext 
        );
    
    HRESULT CreateColorContextFromFilename(
        PCWSTR filename,
        ID2D1ColorContext *colorContext 
        );
    
    HRESULT CreateColorContextFromWicColorContext(
        IWICColorContext wicColorContext,
        ID2D1ColorContext *colorContext 
        );
    
    /// <summary>
    /// Creates a bitmap from a DXGI surface with a set of extended properties.
    /// </summary>
    HRESULT CreateBitmapFromDxgiSurface(
        IDXGISurface surface,
        const(D2D1_BITMAP_PROPERTIES1)* bitmapProperties,
        ID2D1Bitmap1* bitmap 
        );
    
    /// <summary>
    /// Create a new effect, the effect must either be built in or previously registered
    /// through ID2D1Factory1::RegisterEffectFromStream or
    /// ID2D1Factory1::RegisterEffectFromString.
    /// </summary>
    HRESULT CreateEffect(
        REFCLSID effectId,
        ID2D1Effect *effect 
        );
    
    /// <summary>
    /// A gradient stop collection represents a set of stops in an ideal unit length.
    /// This is the source resource for a linear gradient and radial gradient brush.
    /// </summary>
    /// <param name="preInterpolationSpace">Specifies both the input color space and the
    /// space in which the color interpolation occurs.</param>
    /// <param name="postInterpolationSpace">Specifies the color space colors will be
    /// converted to after interpolation occurs.</param>
    /// <param name="bufferPrecision">Specifies the precision in which the gradient
    /// buffer will be held.</param>
    /// <param name="extendMode">Specifies how the gradient will be extended outside of
    /// the unit length.</param>
    /// <param name="colorInterpolationMode">Determines if colors will be interpolated
    /// in straight alpha or premultiplied alpha space.</param>
    HRESULT CreateGradientStopCollection(
        const(D2D1_GRADIENT_STOP)* straightAlphaGradientStops,
        UINT32 straightAlphaGradientStopsCount,
        D2D1_COLOR_SPACE preInterpolationSpace,
        D2D1_COLOR_SPACE postInterpolationSpace,
        D2D1_BUFFER_PRECISION bufferPrecision,
        D2D1_EXTEND_MODE extendMode,
        D2D1_COLOR_INTERPOLATION_MODE colorInterpolationMode,
        ID2D1GradientStopCollection1 *gradientStopCollection1 
        );
    
    /* using ID2D1RenderTarget::CreateGradientStopCollection; */
    HRESULT CreateGradientStopCollection(
        const(D2D1_GRADIENT_STOP)* gradientStops,
        UINT32 gradientStopsCount,
        
        //
        // Specifies which space the color interpolation occurs in.
        //
        D2D1_GAMMA colorInterpolationGamma,
        
        //
        // Specifies how the gradient will be extended outside of the unit length.
        //
        D2D1_EXTEND_MODE extendMode,
        /*out*/ ID2D1GradientStopCollection* gradientStopCollection 
        );
    
    /// <summary>
    /// Creates an image brush, the input image can be any type of image, including a
    /// bitmap, effect and a command list.
    /// </summary>
    HRESULT CreateImageBrush(
        ID2D1Image image,
        const(D2D1_IMAGE_BRUSH_PROPERTIES)* imageBrushProperties,
        const(D2D1_BRUSH_PROPERTIES)* brushProperties,
        ID2D1ImageBrush *imageBrush 
        );
    
    HRESULT CreateBitmapBrush(
        ID2D1Bitmap bitmap,
        const(D2D1_BITMAP_BRUSH_PROPERTIES1)* bitmapBrushProperties,
        const(D2D1_BRUSH_PROPERTIES)* brushProperties,
        ID2D1BitmapBrush1 *bitmapBrush 
        );
    
    /* using ID2D1RenderTarget::CreateBitmapBrush; */
    HRESULT CreateBitmapBrush(
        ID2D1Bitmap bitmap,
        const(D2D1_BITMAP_BRUSH_PROPERTIES)* bitmapBrushProperties,
        const(D2D1_BRUSH_PROPERTIES)* brushProperties,
        /*out*/ ID2D1BitmapBrush* bitmapBrush 
        );
    
    /// <summary>
    /// Creates a new command list.
    /// </summary>
    HRESULT CreateCommandList(ID2D1CommandList *commandList);
    
    /// <summary>
    /// Indicates whether the format is supported by D2D.
    /// </summary>
    BOOL IsDxgiFormatSupported(DXGI_FORMAT format) const;
    
    /// <summary>
    /// Indicates whether the buffer precision is supported by D2D.
    /// </summary>
    BOOL IsBufferPrecisionSupported(D2D1_BUFFER_PRECISION bufferPrecision) const;
    
    /// <summary>
    /// This retrieves the local-space bounds in DIPs of the current image using the
    /// device context DPI.
    /// </summary>
    HRESULT GetImageLocalBounds(
        ID2D1Image image,
        D2D1_RECT_F* localBounds 
        ) const;
    
    /// <summary>
    /// This retrieves the world-space bounds in DIPs of the current image using the
    /// device context DPI.
    /// </summary>
    HRESULT GetImageWorldBounds(
        ID2D1Image image,
        D2D1_RECT_F* worldBounds 
        ) const;
    
    /// <summary>
    /// Retrieves the world-space bounds in DIPs of the glyph run using the device
    /// context DPI.
    /// </summary>
    HRESULT GetGlyphRunWorldBounds(
        D2D1_POINT_2F baselineOrigin,
        const(DWRITE_GLYPH_RUN)* glyphRun,
        DWRITE_MEASURING_MODE measuringMode,
        D2D1_RECT_F* bounds 
        ) const;
    
    /// <summary>
    /// Retrieves the device associated with this device context.
    /// </summary>
    void GetDevice(ID2D1Device *device) const;
    
    /// <summary>
    /// Sets the target for this device context to point to the given image. The image
    /// can be a command list or a bitmap created with the D2D1_BITMAP_OPTIONS_TARGET
    /// flag.
    /// </summary>
    void SetTarget(ID2D1Image image);
    
    /// <summary>
    /// Gets the target that this device context is currently pointing to.
    /// </summary>
    void GetTarget(ID2D1Image *image) const;
    
    /// <summary>
    /// Sets tuning parameters for internal rendering inside the device context.
    /// </summary>
    void SetRenderingControls(const(D2D1_RENDERING_CONTROLS)* renderingControls);
    
    /// <summary>
    /// This retrieves the rendering controls currently selected into the device
    /// context.
    /// </summary>
    void GetRenderingControls(D2D1_RENDERING_CONTROLS* renderingControls) const;
    
    /// <summary>
    /// Changes the primitive blending mode for all of the rendering operations.
    /// </summary>
    void SetPrimitiveBlend(D2D1_PRIMITIVE_BLEND primitiveBlend);
    
    /// <summary>
    /// Returns the primitive blend currently selected into the device context.
    /// </summary>
    D2D1_PRIMITIVE_BLEND GetPrimitiveBlend() const;
    
    /// <summary>
    /// Changes the units used for all of the rendering operations.
    /// </summary>
    void SetUnitMode(D2D1_UNIT_MODE unitMode);
    
    /// <summary>
    /// Returns the unit mode currently set on the device context.
    /// </summary>
    D2D1_UNIT_MODE GetUnitMode() const;
    
    /// <summary>
    /// Draws the glyph run with an extended description to describe the glyphs.
    /// </summary>
    void DrawGlyphRun(
        D2D1_POINT_2F baselineOrigin,
        const(DWRITE_GLYPH_RUN)* glyphRun,
        const(DWRITE_GLYPH_RUN_DESCRIPTION)* glyphRunDescription,
        ID2D1Brush foregroundBrush,
        DWRITE_MEASURING_MODE measuringMode = DWRITE_MEASURING_MODE_NATURAL 
        );
    
    /* using ID2D1RenderTarget::DrawGlyphRun; */
    void DrawGlyphRun(
        D2D1_POINT_2F baselineOrigin,
        const(DWRITE_GLYPH_RUN)* glyphRun,
        ID2D1Brush foregroundBrush,
        DWRITE_MEASURING_MODE measuringMode = DWRITE_MEASURING_MODE_NATURAL 
        );
    
    /// <summary>
    /// Draw an image to the device context. The image represents either a concrete
    /// bitmap or the output of an effect graph.
    /// </summary>
    void DrawImage(
        ID2D1Image image,
        const(D2D1_POINT_2F)* targetOffset = null,
        const(D2D1_RECT_F)* imageRectangle = null,
        D2D1_INTERPOLATION_MODE interpolationMode = D2D1_INTERPOLATION_MODE_LINEAR,
        D2D1_COMPOSITE_MODE compositeMode = D2D1_COMPOSITE_MODE_SOURCE_OVER 
        );
    
    /// <summary>
    /// Draw a metafile to the device context.
    /// </summary>
    void DrawGdiMetafile(
        ID2D1GdiMetafile gdiMetafile,
        const(D2D1_POINT_2F)* targetOffset = null 
        );
    
    void DrawBitmap(
        ID2D1Bitmap bitmap,
        const(D2D1_RECT_F)* destinationRectangle,
        FLOAT opacity,
        D2D1_INTERPOLATION_MODE interpolationMode,
        const(D2D1_RECT_F)* sourceRectangle = null,
        const(D2D1_MATRIX_4X4_F)* perspectiveTransform = null 
        );
    
    /* using ID2D1RenderTarget::DrawBitmap; */
    void DrawBitmap(
        ID2D1Bitmap bitmap,
        const(D2D1_RECT_F)* destinationRectangle = null,
        FLOAT opacity = 1.0f,
        D2D1_BITMAP_INTERPOLATION_MODE interpolationMode = D2D1_BITMAP_INTERPOLATION_MODE_LINEAR,
        const(D2D1_RECT_F)* sourceRectangle = null 
        );
    
    /// <summary>
    /// Push a layer on the device context.
    /// </summary>
    void PushLayer(
        const(D2D1_LAYER_PARAMETERS1)* layerParameters,
        ID2D1Layer layer 
        );
    
    /* using ID2D1RenderTarget::PushLayer; */
    void PushLayer(
        const(D2D1_LAYER_PARAMETERS)* layerParameters,
        ID2D1Layer layer 
        );
    
    /// <summary>
    /// This indicates that a portion of an effect's input is invalid. This method can
    /// be called many times.
    /// </summary>
    HRESULT InvalidateEffectInputRectangle(
        ID2D1Effect effect,
        UINT32 input,
        const(D2D1_RECT_F)* inputRectangle 
        );
    
    /// <summary>
    /// Gets the number of invalid ouptut rectangles that have accumulated at the
    /// effect.
    /// </summary>
    HRESULT GetEffectInvalidRectangleCount(
        ID2D1Effect effect,
        UINT32* rectangleCount 
        );
    
    /// <summary>
    /// Gets the invalid rectangles that are at the output of the effect.
    /// </summary>
    HRESULT GetEffectInvalidRectangles(
        ID2D1Effect effect,
        D2D1_RECT_F* rectangles,
        UINT32 rectanglesCount 
        );
    
    /// <summary>
    /// Gets the maximum region of each specified input which would be used during a
    /// subsequent rendering operation
    /// </summary>
    HRESULT GetEffectRequiredInputRectangles(
        ID2D1Effect* renderEffect,
        const(D2D1_RECT_F)* renderImageRectangle,
        const(D2D1_EFFECT_INPUT_DESCRIPTION)* inputDescriptions,
        D2D1_RECT_F* requiredInputRects,
        UINT32 inputCount 
        );
    
    /// <summary>
    /// Fill using the alpha channel of the supplied opacity mask bitmap. The brush
    /// opacity will be modulated by the mask. The render target antialiasing mode must
    /// be set to aliased.
    /// </summary>
    void FillOpacityMask(
        ID2D1Bitmap opacityMask,
        ID2D1Brush brush,
        const(D2D1_RECT_F)* destinationRectangle = null,
        const(D2D1_RECT_F)* sourceRectangle = null 
        );
    
    /* using ID2D1RenderTarget::FillOpacityMask; */
    void FillOpacityMask(
        ID2D1Bitmap opacityMask,
        ID2D1Brush brush,
        D2D1_OPACITY_MASK_CONTENT content,
        const(D2D1_RECT_F)* destinationRectangle = null,
        const(D2D1_RECT_F)* sourceRectangle = null 
        );
    
    final
    HRESULT
    CreateBitmap(
        D2D1_SIZE_U size,
        const(void)* sourceData,
        UINT32 pitch,
        const D2D1_BITMAP_PROPERTIES1 bitmapProperties,
        out ID2D1Bitmap1 bitmap 
        )  
    {
        return CreateBitmap(size, sourceData, pitch, &bitmapProperties, &bitmap);
    }
    
    /// <summary>
    /// Create a D2D bitmap by copying a WIC bitmap.
    /// </summary>
    final
    HRESULT
    CreateBitmapFromWicBitmap(
        IWICBitmapSource wicBitmapSource,
        const D2D1_BITMAP_PROPERTIES1 bitmapProperties,
        out ID2D1Bitmap1 bitmap 
        )  
    {
        return CreateBitmapFromWicBitmap(wicBitmapSource, &bitmapProperties, &bitmap);
    }
    
    /// <summary>
    /// Create a D2D bitmap by copying a WIC bitmap.
    /// </summary>
    final
    HRESULT
    CreateBitmapFromWicBitmap(
        IWICBitmapSource wicBitmapSource,
        out ID2D1Bitmap1 bitmap 
        )  
    {
        return CreateBitmapFromWicBitmap(wicBitmapSource, null, &bitmap);
    }
    
    final
    HRESULT
    CreateBitmapFromDxgiSurface(
        IDXGISurface surface,
        const D2D1_BITMAP_PROPERTIES1 bitmapProperties,
        out ID2D1Bitmap1 bitmap 
        )  
    {
        return CreateBitmapFromDxgiSurface(surface, &bitmapProperties, &bitmap);
    }
    
    final
    HRESULT
    CreateImageBrush(
        ID2D1Image image,
        const D2D1_IMAGE_BRUSH_PROPERTIES imageBrushProperties,
        const D2D1_BRUSH_PROPERTIES brushProperties,
        out ID2D1ImageBrush imageBrush 
        )  
    {
        return CreateImageBrush(image, &imageBrushProperties, &brushProperties, &imageBrush);
    }
    
    final
    HRESULT
    CreateImageBrush(
        ID2D1Image image,
        const D2D1_IMAGE_BRUSH_PROPERTIES imageBrushProperties,
        out ID2D1ImageBrush imageBrush 
        )  
    {
        return CreateImageBrush(image,&imageBrushProperties, null, &imageBrush);
    }
    
    final
    HRESULT
    CreateBitmapBrush(
        ID2D1Bitmap bitmap,
        out ID2D1BitmapBrush1 bitmapBrush 
        )  
    {
        return CreateBitmapBrush(bitmap, null, null, &bitmapBrush);
    }
    
    final
    HRESULT
    CreateBitmapBrush(
        ID2D1Bitmap bitmap,
        const D2D1_BITMAP_BRUSH_PROPERTIES1 bitmapBrushProperties,
        out ID2D1BitmapBrush1 bitmapBrush 
        )  
    {
        return CreateBitmapBrush(bitmap, &bitmapBrushProperties, null, &bitmapBrush);
    }
    
    final
    HRESULT
    CreateBitmapBrush(
        ID2D1Bitmap bitmap,
        const D2D1_BITMAP_BRUSH_PROPERTIES1 bitmapBrushProperties,
        const D2D1_BRUSH_PROPERTIES brushProperties,
        out ID2D1BitmapBrush1 bitmapBrush 
        )  
    {
        return CreateBitmapBrush(bitmap, &bitmapBrushProperties, &brushProperties, &bitmapBrush);
    }
    
    /// <summary>
    /// Draws the output of the effect as an image.
    /// </summary>
    final
    void
    DrawImage(
        ID2D1Effect effect,
        const(D2D1_POINT_2F)* targetOffset = null,
        const(D2D1_RECT_F)* imageRectangle = null,
        D2D1_INTERPOLATION_MODE interpolationMode = D2D1_INTERPOLATION_MODE_LINEAR,
        D2D1_COMPOSITE_MODE compositeMode = D2D1_COMPOSITE_MODE_SOURCE_OVER 
        )  
    {
        
        ID2D1Image output = null;
        effect.GetOutput(&output); scope(exit) output.Release();
        DrawImage(output, targetOffset, imageRectangle, interpolationMode, compositeMode);
    }
    
    final
    void
    DrawImage(
        ID2D1Image image,
        D2D1_INTERPOLATION_MODE interpolationMode,
        D2D1_COMPOSITE_MODE compositeMode = D2D1_COMPOSITE_MODE_SOURCE_OVER 
        )  
    {
        DrawImage(image, null, null, interpolationMode, compositeMode);
    }
    
    final
    void
    DrawImage(
        ID2D1Effect effect,
        D2D1_INTERPOLATION_MODE interpolationMode,
        D2D1_COMPOSITE_MODE compositeMode = D2D1_COMPOSITE_MODE_SOURCE_OVER 
        )  
    {
        DrawImage(effect, null, null, interpolationMode, compositeMode);
    }
    
    final
    void
    DrawImage(
        ID2D1Image image,
        D2D1_POINT_2F targetOffset,
        D2D1_INTERPOLATION_MODE interpolationMode = D2D1_INTERPOLATION_MODE_LINEAR,
        D2D1_COMPOSITE_MODE compositeMode = D2D1_COMPOSITE_MODE_SOURCE_OVER 
        )  
    {
        DrawImage(image, &targetOffset, null, interpolationMode, compositeMode);
    }
    
    final
    void
    DrawImage(
        ID2D1Effect effect,
        D2D1_POINT_2F targetOffset,
        D2D1_INTERPOLATION_MODE interpolationMode = D2D1_INTERPOLATION_MODE_LINEAR,
        D2D1_COMPOSITE_MODE compositeMode = D2D1_COMPOSITE_MODE_SOURCE_OVER 
        )  
    {
        DrawImage(effect, &targetOffset, null, interpolationMode, compositeMode);
    }

    final
    void
    DrawImage(
        ID2D1Image image,
        D2D1_POINT_2F targetOffset,
        const D2D1_RECT_F imageRectangle,
        D2D1_INTERPOLATION_MODE interpolationMode = D2D1_INTERPOLATION_MODE_LINEAR,
        D2D1_COMPOSITE_MODE compositeMode = D2D1_COMPOSITE_MODE_SOURCE_OVER 
        )  
    {
        DrawImage(image, &targetOffset, &imageRectangle, interpolationMode, compositeMode);
    }
    
    final
    void
    DrawImage(
        ID2D1Effect effect,
        D2D1_POINT_2F targetOffset,
        const D2D1_RECT_F imageRectangle,
        D2D1_INTERPOLATION_MODE interpolationMode = D2D1_INTERPOLATION_MODE_LINEAR,
        D2D1_COMPOSITE_MODE compositeMode = D2D1_COMPOSITE_MODE_SOURCE_OVER 
        )  
    {
        DrawImage(effect, &targetOffset, &imageRectangle, interpolationMode, compositeMode);
    }
    
    final
    void
    PushLayer(
        const D2D1_LAYER_PARAMETERS1 layerParameters,
        ID2D1Layer layer 
        )  
    {
        PushLayer(&layerParameters, layer);
    }
    
    final
    void
    DrawGdiMetafile(
        ID2D1GdiMetafile gdiMetafile,
        D2D1_POINT_2F targetOffset 
        )  
    {
        DrawGdiMetafile(gdiMetafile, &targetOffset);
    }
    
    final
    void
    DrawBitmap(
        ID2D1Bitmap bitmap,
        const D2D1_RECT_F destinationRectangle,
        FLOAT opacity,
        D2D1_INTERPOLATION_MODE interpolationMode,
        const(D2D1_RECT_F)* sourceRectangle = null,
        const(D2D1_MATRIX_4X4_F)* perspectiveTransform = null 
        )  
    {
        DrawBitmap(bitmap, &destinationRectangle, opacity, interpolationMode, sourceRectangle, perspectiveTransform);
    }
    
    final
    void
    DrawBitmap(
        ID2D1Bitmap bitmap,
        const D2D1_RECT_F destinationRectangle,
        FLOAT opacity,
        D2D1_INTERPOLATION_MODE interpolationMode,
        const D2D1_RECT_F sourceRectangle,
        const(D2D1_MATRIX_4X4_F)* perspectiveTransform = null 
        )  
    {
        DrawBitmap(bitmap, &destinationRectangle, opacity, interpolationMode, &sourceRectangle, perspectiveTransform);
    }
    
    final
    void
    DrawBitmap(
        ID2D1Bitmap bitmap,
        const D2D1_RECT_F destinationRectangle,
        FLOAT opacity,
        D2D1_INTERPOLATION_MODE interpolationMode,
        const D2D1_RECT_F sourceRectangle,
        const D2D1_MATRIX_4X4_F perspectiveTransform 
        )  
    {
        DrawBitmap(bitmap, &destinationRectangle, opacity, interpolationMode, &sourceRectangle, &perspectiveTransform);
    }
    
    final
    void
    FillOpacityMask(
        ID2D1Bitmap opacityMask,
        ID2D1Brush brush,
        const D2D1_RECT_F destinationRectangle,
        const(D2D1_RECT_F)* sourceRectangle = null 
        )  
    {
        FillOpacityMask(opacityMask, brush, &destinationRectangle, sourceRectangle);
    }
    
    final
    void
    FillOpacityMask(
        ID2D1Bitmap opacityMask,
        ID2D1Brush brush,
        const D2D1_RECT_F destinationRectangle,
        const D2D1_RECT_F sourceRectangle 
        )  
    {
        FillOpacityMask(opacityMask, brush, &destinationRectangle, &sourceRectangle);
    }
    
    /// <summary>
    /// Sets tuning parameters for internal rendering inside the device context.
    /// </summary>
    final
    void
    SetRenderingControls(
        const D2D1_RENDERING_CONTROLS renderingControls 
        )  
    {
        return SetRenderingControls(&renderingControls);
    }
} // interface ID2D1DeviceContext


mixin(uuid!(ID2D1Device, "47dd575d-ac05-4cdd-8049-9b02cd16f44c"));
/// <summary>
/// The device defines a resource domain whose objects and device contexts can be
/// used together.
/// </summary>
interface ID2D1Device : ID2D1Resource
{
	extern(Windows):
    /// <summary>
    /// Creates a new device context with no initially assigned target.
    /// </summary>
    HRESULT CreateDeviceContext(
        D2D1_DEVICE_CONTEXT_OPTIONS options,
        ID2D1DeviceContext *deviceContext 
        );
    
    /// <summary>
    /// Creates a D2D print control.
    /// </summary>
    HRESULT CreatePrintControl(
        IWICImagingFactory wicFactory,
        IPrintDocumentPackageTarget documentTarget,
        const(D2D1_PRINT_CONTROL_PROPERTIES)* printControlProperties,
        ID2D1PrintControl *printControl 
        );
    
    /// <summary>
    /// Sets the maximum amount of texture memory to maintain before evicting caches.
    /// </summary>
    void SetMaximumTextureMemory(UINT64 maximumInBytes);
    
    /// <summary>
    /// Gets the maximum amount of texture memory to maintain before evicting caches.
    /// </summary>
    UINT64 GetMaximumTextureMemory() const;
    
    /// <summary>
    /// Clears all resources that are cached but not held in use by the application
    /// through an interface reference.
    /// </summary>
    void ClearResources(UINT32 millisecondsSinceUse = 0);
    
    final
    HRESULT
    CreatePrintControl(
        IWICImagingFactory wicFactory,
        IPrintDocumentPackageTarget documentTarget,
        const D2D1_PRINT_CONTROL_PROPERTIES printControlProperties,
        out ID2D1PrintControl printControl 
        )  
    {
        return CreatePrintControl(wicFactory, documentTarget, &printControlProperties, &printControl);
    }
} // interface ID2D1Device


mixin(uuid!(ID2D1Factory1, "bb12d362-daee-4b9a-aa1d-14ba401cfa1f"));
/// <summary>
/// Creates Direct2D resources.
/// </summary>
interface ID2D1Factory1 : ID2D1Factory
{
	extern(Windows):
    /// <summary>
    /// This creates a new Direct2D device from the given IDXGIDevice.
    /// </summary>
    HRESULT CreateDevice(
        IDXGIDevice dxgiDevice,
        ID2D1Device *d2dDevice 
        );
    
    /// <summary>
    /// This creates a stroke style with the ability to preserve stroke width in various
    /// ways.
    /// </summary>
    HRESULT CreateStrokeStyle(
        const(D2D1_STROKE_STYLE_PROPERTIES1)* strokeStyleProperties,
        const(FLOAT)* dashes,
        UINT32 dashesCount,
        ID2D1StrokeStyle1 *strokeStyle 
        );
    
    /* using ID2D1Factory::CreateStrokeStyle; */
    HRESULT CreateStrokeStyle(
        const(D2D1_STROKE_STYLE_PROPERTIES)* strokeStyleProperties,
        const(FLOAT)* dashes,
        UINT32 dashesCount,
        /*out*/ ID2D1StrokeStyle* strokeStyle 
        );
    
    /// <summary>
    /// Creates a path geometry with new operational methods.
    /// </summary>
    HRESULT CreatePathGeometry(ID2D1PathGeometry1 *pathGeometry);
    
    /* using ID2D1Factory::CreatePathGeometry; */
    HRESULT CreatePathGeometry(
        /*out*/ ID2D1PathGeometry* pathGeometry 
        );
    
    /// <summary>
    /// Creates a new drawing state block, this can be used in subsequent
    /// SaveDrawingState and RestoreDrawingState operations on the render target.
    /// </summary>
    HRESULT CreateDrawingStateBlock(
        const(D2D1_DRAWING_STATE_DESCRIPTION1)* drawingStateDescription,
        IDWriteRenderingParams textRenderingParams,
        ID2D1DrawingStateBlock1 *drawingStateBlock 
        );
    
    /* using ID2D1Factory::CreateDrawingStateBlock; */
    HRESULT CreateDrawingStateBlock(
        const(D2D1_DRAWING_STATE_DESCRIPTION)* drawingStateDescription,
        IDWriteRenderingParams textRenderingParams,
        /*out*/ ID2D1DrawingStateBlock* drawingStateBlock 
		);
    
    /// <summary>
    /// Creates a new GDI metafile.
    /// </summary>
    HRESULT CreateGdiMetafile(
        IStream metafileStream,
        ID2D1GdiMetafile *metafile 
        );
    
    /// <summary>
    /// This globally registers the given effect. The effect can later be instantiated
    /// by using the registered class id. The effect registration is reference counted.
    /// </summary>
    HRESULT RegisterEffectFromStream(
        REFCLSID classId,
        IStream propertyXml,
        const(D2D1_PROPERTY_BINDING)* bindings,
        UINT32 bindingsCount,
        const PD2D1_EFFECT_FACTORY effectFactory 
        );
    
    /// <summary>
    /// This globally registers the given effect. The effect can later be instantiated
    /// by using the registered class id. The effect registration is reference counted.
    /// </summary>
    HRESULT RegisterEffectFromString(
        REFCLSID classId,
        PCWSTR propertyXml,
        const(D2D1_PROPERTY_BINDING)* bindings,
        UINT32 bindingsCount,
        const PD2D1_EFFECT_FACTORY effectFactory 
        );
    
    /// <summary>
    /// This unregisters the given effect by its class id, you need to call
    /// UnregisterEffect for every call to ID2D1Factory1::RegisterEffectFromStream and
    /// ID2D1Factory1::RegisterEffectFromString to completely unregister it.
    /// </summary>
    HRESULT UnregisterEffect(REFCLSID classId);
    
    /// <summary>
    /// This returns all of the registered effects in the process, including any
    /// built-in effects.
    /// </summary>
    /// <param name="effectsReturned">The number of effects returned into the passed in
    /// effects array.</param>
    /// <param name="effectsRegistered">The number of effects currently registered in
    /// the system.</param>
    HRESULT GetRegisteredEffects(
        CLSID* effects,
        UINT32 effectsCount,
        UINT32* effectsReturned,
        UINT32* effectsRegistered 
        ) const;
    
    /// <summary>
    /// This retrieves the effect properties for the given effect, all of the effect
    /// properties will be set to a default value since an effect is not instantiated to
    /// implement the returned property interface.
    /// </summary>
    HRESULT GetEffectProperties(
        REFCLSID effectId,
        ID2D1Properties *properties 
        ) const;
    
    final
    HRESULT
    CreateStrokeStyle(
        const D2D1_STROKE_STYLE_PROPERTIES1 strokeStyleProperties,
        const(FLOAT)* dashes,
        UINT32 dashesCount,
        out ID2D1StrokeStyle1 strokeStyle 
        )  
    {
        return CreateStrokeStyle(&strokeStyleProperties, dashes, dashesCount, &strokeStyle);
    }
    // D-style impl
    final
    HRESULT
    CreateStrokeStyle(
        const D2D1_STROKE_STYLE_PROPERTIES1 strokeStyleProperties,
        const(FLOAT)[] dashes,
        out ID2D1StrokeStyle1 strokeStyle 
        )  
    {
        return CreateStrokeStyle(&strokeStyleProperties, &dashes[0], cast(UINT32)dashes.length, &strokeStyle);
    }
    
    final
    HRESULT
    CreateDrawingStateBlock(
        const D2D1_DRAWING_STATE_DESCRIPTION1 drawingStateDescription,
        out ID2D1DrawingStateBlock1 drawingStateBlock 
        )  
    {
        return CreateDrawingStateBlock(&drawingStateDescription, null, &drawingStateBlock);
    }
    
    final
    HRESULT
    CreateDrawingStateBlock(out ID2D1DrawingStateBlock1 drawingStateBlock)  
    {
        return CreateDrawingStateBlock(null, null, &drawingStateBlock);
    }
} // interface ID2D1Factory1


mixin(uuid!(ID2D1Multithread, "31e6e7bc-e0ff-4d46-8c64-a0a8c41c15d3"));
/// <summary>
/// A locking mechanism from a Direct2D factory that Direct2D uses to control
/// exclusive resource access in an app that is uses multiple threads.
/// </summary>
interface ID2D1Multithread : IUnknown
{
	extern(Windows):
    /// <summary>
    /// Returns whether the D2D factory was created with
    /// D2D1_FACTORY_TYPE_MULTI_THREADED.
    /// </summary>
    BOOL GetMultithreadProtected() const;
    
    /// <summary>
    /// Enters the D2D API critical section, if it exists.
    /// </summary>
    void Enter();
    
    /// <summary>
    /// Leaves the D2D API critical section, if it exists.
    /// </summary>
    void Leave();
} // interface ID2D1Multithread

extern(Windows)
{
    HRESULT 
    D2D1CreateDevice(
        IDXGIDevice dxgiDevice,
        const(D2D1_CREATION_PROPERTIES)* creationProperties,
        ID2D1Device *d2dDevice
        ); 
        
    HRESULT 
    D2D1CreateDeviceContext(
        IDXGISurface dxgiSurface,
        const(D2D1_CREATION_PROPERTIES)* creationProperties,
        ID2D1DeviceContext *d2dDeviceContext
        ); 

    D2D1_COLOR_F
    D2D1ConvertColorSpace(
        D2D1_COLOR_SPACE sourceColorSpace,
        D2D1_COLOR_SPACE destinationColorSpace,
        const(D2D1_COLOR_F)* color
        );
            
    void
    D2D1SinCos(
      FLOAT angle,
      FLOAT* s,
      FLOAT* c
      );
           
    FLOAT
    D2D1Tan(FLOAT angle);
        
    FLOAT
    D2D1Vec3Length(
      FLOAT x,
      FLOAT y,
      FLOAT z
      );
}

// public import D2D1 = directx.d2d1_1helper; TODO: Resolve namespace translation

HRESULT 
D2D1CreateDevice()(
    IDXGIDevice dxgiDevice,
    const D2D1_CREATION_PROPERTIES creationProperties,
    out ID2D1Device d2dDevice
    ) 
{

    return
        D2D1CreateDevice(
            dxgiDevice,
            &creationProperties,
            &d2dDevice);
} 
    
HRESULT 
D2D1CreateDeviceContext()(
    IDXGISurface dxgiSurface,
    const D2D1_CREATION_PROPERTIES creationProperties,
    out ID2D1DeviceContext d2dDeviceContext
    ) 
{
    return
        D2D1CreateDeviceContext(
            dxgiSurface,
            &creationProperties,
            &d2dDeviceContext);
}
